{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    count = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if count == 0:\n                start = i\n            count += 1\n        elif char == ')':\n            count -= 1\n            if count == 0:\n                result.append(paren_string[start:i+1])\n    return result"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Truncates a decimal number to its fractional part.\n    \n    Examples:\n    >>> truncate_number(3.5)\n    0.5\n    >>> truncate_number(6.78)\n    0.78\n    \n    Args:\n    number (float): The decimal number to truncate.\n    \n    Returns:\n    float: The fractional part of the input number.\n    \n    Raises:\n    ValueError: If the input number is not positive.\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Input number must be positive\")\n    return number % 1"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean absolute deviation of a list of numbers.\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        float: The mean absolute deviation of the input numbers.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the sum of absolute differences from the mean\n    absolute_diff_sum = sum(abs(x - mean_value) for x in numbers)\n    \n    # Calculate the mean absolute deviation\n    mean_abs_deviation = absolute_diff_sum / len(numbers)\n    \n    return mean_abs_deviation"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    Intersperse a list of numbers with a given delimiter.\n\n    Args:\n        numbers (List[int]): The list of numbers.\n        delimiter (int): The delimiter to intersperse between the numbers.\n\n    Returns:\n        List[int]: The list with the delimiter interspersed between each number.\n\n    Examples:\n        >>> intersperse([1, 2, 3], 4)\n        [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n    return [x for pair in zip(numbers, [delimiter] * (len(numbers) - 1)) for x in pair] + [numbers[-1]]"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Returns a list containing the maximum depth of nested parentheses for each group of parentheses in the input string.\n\n    Args:\n    paren_string (str): A string containing groups of nested parentheses.\n\n    Returns:\n    List[int]: A list containing the maximum depth of nested parentheses for each group.\n\n    Example:\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize the result list\n    result = []\n\n    # Split the input string into groups of parentheses\n    groups = paren_string.split()\n\n    # Iterate over each group and calculate the maximum depth of nested parentheses\n    for group in groups:\n        max_depth = 0\n        depth = 0\n        # Iterate over each character in the group\n        for char in group:\n            # Increment depth for '(' and update max_depth if needed\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            # Decrement depth for ')'\n            elif char == ')':\n                depth -= 1\n        # Append the maximum depth of the current group to the result list\n        result.append(max_depth)\n\n    # Return the resulting list\n    return result"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\nfrom functools import reduce\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:  # Handling empty list\n        return 0, 1\n    else:\n        sum_result = sum(numbers)\n        product_result = reduce(lambda x, y: x * y, numbers)\n        return sum_result, product_result"}
{"task_id": "HumanEval/9", "completion": "from typing import List\nfrom collections import deque\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_values = []\n    max_value = numbers[0]  # Initialize with the first element of the list\n    max_window = deque([max_value])\n    \n    for num in numbers:\n        if num > max_value:\n            max_value = num\n            max_window.clear()\n        max_window.append(max_value)\n        rolling_max_values.append(max_window[0])\n    return rolling_max_values"}
{"task_id": "HumanEval/10", "completion": "def make_palindrome(input_string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string.\n    \n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\n    Args:\n    input_string (str): The string to be converted into a palindrome.\n\n    Returns:\n    str: The shortest palindrome that begins with the supplied string.\n\n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not input_string:\n        return ''\n    index = 0\n    while index < len(input_string):\n        if input_string[index:] == input_string[index:][::-1]:\n            break\n        index += 1\n    return input_string + input_string[:index][::-1]"}
{"task_id": "HumanEval/11", "completion": "    assert len(a) == len(b)\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string from a list of strings.\n    \n    Parameters:\n        strings (List[str]): A list of strings to find the longest from.\n        \n    Returns:\n        Optional[str]: The longest string from the input list. \n                       Returns None if the input list is empty.\n                       \n    Examples:\n        >>> longest([])\n        \n        >>> longest(['a', 'b', 'c'])\n        'a'\n        >>> longest(['a', 'bb', 'ccc'])\n        'ccc'\n        >>> longest(['aaa', 'bbb', 'ccc'])\n        'aaa'\n        >>> longest(['aaa', 'bbb', 'ccc', 'dd', 'eee'])\n        'ccc'\n    \"\"\"\n    if not strings:\n        return None\n\n    longest_string = max(strings, key=len)\n    return longest_string"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of two integers a and b\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Inputs must be integers\")\n\n    x, y = abs(a), abs(b)  # Ensure positive values for correct computation\n    while y != 0:\n        if x > y:\n            x -= y\n        else:\n            y -= x\n    return x"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"\n    Return list of all prefixes from shortest to longest of the input string\n    \n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\"\n    Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n\n    Args:\n    n (int): The non-negative integer up to which the sequence should be generated.\n\n    Returns:\n    str: A string containing space-delimited numbers.\n\n    Raises:\n    ValueError: If n is a negative integer.\n\n    Examples:\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0:\n        return '0'\n    result = ' '.join(str(i) for i in range(n + 1))\n    return result"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parse the music string and return the corresponding list of beat durations.\n\n    Parameters:\n    music_string (str): The input music string containing notes and separators.\n\n    Returns:\n    List[int]: A list of beat durations parsed from the music string.\n    \"\"\"\n    # Define a dictionary to map note symbols to beat durations\n    note_to_duration = {'o': 4, 'o|': 2, '.|': 1}\n    \n    beat_durations = []\n    \n    # Iterate over each note in the music string\n    for note in music_string.split():\n        # Check if the note is in the dictionary, if so, append its corresponding duration\n        if note in note_to_duration:\n            beat_durations.append(note_to_duration[note])\n        # Ignore any other characters, such as spaces\n        else:\n            pass\n            \n    return beat_durations"}
{"task_id": "HumanEval/18", "completion": "def count_substring_occurrences(text: str, pattern: str) -> int:\n    \"\"\"\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n\n    Args:\n    text: The original string where occurrences are to be counted.\n    pattern: The substring to be searched for.\n\n    Returns:\n    The number of times the substring occurs in the original string.\n    \"\"\"\n\n    return text.count(pattern)"}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    \"\"\"\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    word_to_num = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    num_to_word = {v: k for k, v in word_to_num.items()}  # Reverse mapping for converting numbers back to words\n    \n    words = numbers.split()\n    nums = []\n    for word in words:\n        if word in word_to_num:\n            nums.append(word_to_num[word])\n        else:\n            raise ValueError(f\"Invalid input: '{word}' is not a valid numeral.\")\n    \n    sorted_nums = sorted(nums)\n    sorted_words = [num_to_word[num] for num in sorted_nums]\n    \n    return ' '.join(sorted_words)"}
{"task_id": "HumanEval/20", "completion": "    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    return result"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers, apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1.\n\n    Note: This function expects at least two elements in the input list.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n    \n    smallest = min(numbers)\n    largest = max(numbers)\n    range_value = largest - smallest\n    scaled_numbers = [(num - smallest) / range_value for num in numbers]\n    return scaled_numbers"}
{"task_id": "HumanEval/22", "completion": "    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"\n    Return the length of the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The length of the input string.\n\n    Examples:\n        >>> strlen('')\n        0\n        >>> strlen('abc')\n        3\n    \"\"\"\n    if string is None:\n        return 0  # Return 0 for None input\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")  # Raise an error for non-string inputs\n    return len(string)"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    Find the largest divisor of a given positive integer.\n\n    Args:\n        n (int): The positive integer to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of the given integer.\n\n    Raises:\n        ValueError: If the input is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    for divisor in range(int(n ** 0.5), 0, -1):\n        if n % divisor == 0:\n            return divisor"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(nums))"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    \"\"\"\n    Return a string with flipped case for each character.\n\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    if not string:\n        return ''\n\n    flipped_string = ''.join([char.upper() if char.islower() else char.lower() if char.isupper() else char for char in string])\n    return flipped_string"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"Input must be a list of strings\")\n    return ''.join(strings)"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings (List[str]): The list of strings to filter.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: The filtered list of strings.\n\n    Examples:\n        >>> filter_by_prefix([], 'a')\n        []\n        >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n        ['abc', 'array']\n    \"\"\"\n    filtered_strings = []\n    for string in strings:\n        if string.startswith(prefix):\n            filtered_strings.append(string)\n    return filtered_strings"}
{"task_id": "HumanEval/30", "completion": "from typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    \"\"\"\n    Return a list containing only the positive numbers from the input list.\n\n    Parameters:\n    l (List[int]): The input list.\n\n    Returns:\n    List[int]: A list containing only the positive numbers from the input list.\n    \"\"\"\n    if not l or all(num <= 0 for num in l):\n        return []\n    \n    return [num for num in l if num > 0]"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"\n    Check if a given number is prime.\n\n    Parameters:\n    n (int): The number to be checked for primality.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n\n    Raises:\n    ValueError: If the input is not a positive integer.\n\n    Examples:\n    >>> is_prime(2)\n    True\n    >>> is_prime(17)\n    True\n    >>> is_prime(15)\n    False\n    >>> is_prime(0)\n    False\n    >>> is_prime(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/32", "completion": "def find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    \n    # Find the index of the largest non-zero coefficient\n    max_coeff_index = max(range(len(xs)), key=lambda i: abs(xs[i]))\n    \n    # Newton's method to find the zero point\n    x0 = 0.0  # Initial guess\n    max_iterations = 1000\n    tolerance = 1e-10\n    \n    for _ in range(max_iterations):\n        fx = poly(xs, x0)\n        if abs(fx) < tolerance:\n            return x0\n        dfx = sum([i * coeff * math.pow(x0, i - 1) for i, coeff in enumerate(xs)])\n        if dfx == 0:\n            raise ValueError(\"Derivative is zero. Unable to find zero point.\")\n        x0 = x0 - fx / dfx\n    \n    raise ValueError(\"Unable to find zero point within the maximum number of iterations.\")"}
{"task_id": "HumanEval/33", "completion": "def sort_third(input_list: list) -> list:\n    sorted_values = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    sorted_values.sort()\n    return [sorted_values.pop(0) if i % 3 == 0 else input_list[i] for i in range(len(input_list))]"}
{"task_id": "HumanEval/34", "completion": "from typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    \"\"\"Return sorted unique elements in a list.\n\n    Args:\n        l (List[int]): List of integers.\n\n    Returns:\n        List[int]: Sorted list of unique integers.\n        \n    Example:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"}
{"task_id": "HumanEval/35", "completion": "def max_element(lst: list):\n    \"\"\"\n    Return maximum element in the list.\n    >>> max_element([1, 2, 3, 5])\n    5\n    >>> max_element([-1, -10, -3, -5])\n    -1\n    \"\"\"\n    return max(lst) if lst else None"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n\nprint(fizz_buzz(50))\nprint(fizz_buzz(78))\nprint(fizz_buzz(79))"}
{"task_id": "HumanEval/37", "completion": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    Sorts the elements at even indices in the input list.\n    \n    Args:\n        input_list (list): The input list to be processed.\n        \n    Returns:\n        list: A new list with elements at even indices sorted in ascending order.\n        \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not input_list:\n        return []  # Return empty list if input list is empty\n    \n    sorted_even_indices = sorted(input_list[::2])  # Sort even indices\n    result = []\n    for i in range(len(input_list)):\n        if i % 2 == 0:  # even index\n            result.append(sorted_even_indices.pop(0))\n        else:\n            result.append(input_list[i])\n    return result"}
{"task_id": "HumanEval/38", "completion": "def decode_cyclic(encoded_string: str) -> str:\n    \"\"\"\n    Takes an input string encoded with the encode_cyclic function and returns the decoded string.\n    \"\"\"\n    # Split the encoded string into groups of three characters\n    groups = [encoded_string[(3 * i):min((3 * i + 3), len(encoded_string))] for i in range((len(encoded_string) + 2) // 3)]\n    \n    # Reverse the cycling of characters in each group\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    \n    # Join the groups together and return the decoded string\n    return \"\".join(groups)"}
{"task_id": "HumanEval/39", "completion": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Helper function to check if a number is prime.\n\n    Args:\n        num (int): The number to check for primality.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return False\n    elif num == 2:\n        return True\n    elif num % 2 == 0:\n        return False\n    else:\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is both prime and a Fibonacci number.\n\n    Args:\n        n (int): The position of the prime Fibonacci number to find.\n\n    Returns:\n        int: The n-th prime Fibonacci number.\n    \"\"\"\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    \n    fib_count = 2\n    prev, curr = 1, 2\n    \n    while True:\n        next_fib = prev + curr\n        if is_prime(next_fib):\n            fib_count += 1\n            if fib_count == n:\n                return next_fib\n        prev, curr = curr, next_fib"}
{"task_id": "HumanEval/40", "completion": "    l.sort()\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum < 0:\n                left += 1\n            elif current_sum > 0:\n                right -= 1\n            else:\n                return True\n    return False"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int):\n    \"\"\"\n    Output the number of collisions between cars driving left to right and cars driving right to left.\n    \"\"\"\n    if n <= 0:\n        return 0  # Handle edge case when n is 0 or negative\n    else:\n        return n * (n - 1) // 2  # Calculate collisions using combinatorial formula"}
{"task_id": "HumanEval/42", "completion": "    return [i + 1 for i in l]"}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(nums):\n    \"\"\"\n    Returns True if there exist two numbers in the list that sum up to zero,\n    otherwise returns False.\n\n    If the list has less than 2 elements, returns False.\n\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    >>> pairs_sum_to_zero([-1, 1, 0])\n    True\n    >>> pairs_sum_to_zero([-1, -2, -3, 4])\n    False\n    >>> pairs_sum_to_zero([0, 0, 0, 0])\n    True\n    \"\"\"\n\n    if len(nums) < 2:  # Handling edge cases\n        return False\n\n    num_freq = {}  # Dictionary to store frequency of each number\n    for num in nums:\n        num_freq[num] = num_freq.get(num, 0) + 1\n\n    for num in nums:\n        if num != 0 and -num in num_freq:\n            return True\n        elif num == 0 and num_freq[num] > 1:\n            return True\n\n    return False"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int):\n    \"\"\"\n    Convert a decimal number to a given base.\n\n    Args:\n        x (int): The decimal number to convert.\n        base (int): The base to convert the decimal number into. Must be less than 10.\n\n    Returns:\n        str: The decimal number converted to the specified base.\n\n    Raises:\n        ValueError: If the base is not less than 10.\n    \"\"\"\n    if base >= 10:\n        raise ValueError(\"Base must be less than 10.\")\n    \n    if x == 0:\n        return '0'\n    \n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x //= base\n    return result"}
{"task_id": "HumanEval/45", "completion": "    return 0.5 * a * h\n\ndef rectangle_area(l, w):\n    \"\"\"Given length and width return area for a rectangle.\n    >>> rectangle_area(5, 3)\n    15\n    \"\"\"\n    return l * w\n\ndef circle_area(r):\n    \"\"\"Given radius return area for a circle.\n    >>> circle_area(3)\n    28.274333882308138\n    \"\"\"\n    from math import pi\n    return pi * r * r\n\ndef trapezoid_area(a, b, h):\n    \"\"\"Given lengths of two bases and height return area for a trapezoid.\n    >>> trapezoid_area(5, 3, 2)\n    17.5\n    \"\"\"\n    return 0.5 * (a + b) * h\n\ndef polygon_area(s, n):\n    \"\"\"Given side length and number of sides return area for a polygon.\n    >>> polygon_area(5, 6)\n    45.58845892029525\n    \"\"\"\n    from math import pi\n    return (s ** 2) * n / (4 * pi)\n\ndef parallelogram_area(b, h):\n    \"\"\"Given base and height return area for a parallelogram.\n    >>> parallelogram_area(5, 3)\n    15\n    \"\"\"\n    return b * h\n\ndef rhombus_area(d1, d2):\n    \"\"\"Given lengths of two diagonals return area for a rhombus.\n"}
{"task_id": "HumanEval/46", "completion": "    if n < 2:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(n - 3):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n\nprint(fib4(5))\nprint(fib4(6))\nprint(fib4(7))"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n    length = len(l)\n    middle_index = length // 2\n    return (l[middle_index] + l[middle_index - 1]) / 2 if length % 2 == 0 else l[middle_index]"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome.\n    \n    An empty string is considered a palindrome.\n    \n    Parameters:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string is a palindrome, False otherwise.\n    \n    Examples:\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    start = 0\n    end = len(text) - 1\n    while start < end:\n        if text[start] != text[end]:\n            return False\n        start += 1\n        end -= 1\n    return True"}
{"task_id": "HumanEval/49", "completion": "    # Your implementation here\n    return pow(2, n, p)\n\nprint(modp(3, 5))\nprint(modp(1101, 101))\nprint(modp(0, 101))\nprint(modp(3, 11))\nprint(modp(100, 101))"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(input_string, shift):\n    \"\"\"\n    Encode a string by shifting each lowercase letter by a specified number of positions in the alphabet.\n\n    Args:\n        input_string (str): The string to be encoded.\n        shift (int): The number of positions each letter should be shifted.\n\n    Returns:\n        str: The encoded string.\n    \"\"\"\n    encoded_string = \"\"\n    for char in input_string:\n        if char.islower():\n            encoded_char = chr(((ord(char) - 97 + shift) % 26) + 97)\n            encoded_string += encoded_char\n        else:\n            encoded_string += char\n    return encoded_string\n\n\ndef decode_shift(input_string, shift):\n    \"\"\"\n    Decode a string encoded using the encode_shift function.\n\n    Args:\n        input_string (str): The encoded string to be decoded.\n        shift (int): The number of positions each letter was shifted during encoding.\n\n    Returns:\n        str: The decoded string.\n    \"\"\"\n    decoded_string = \"\"\n    for char in input_string:\n        if char.islower():\n            decoded_char = chr(((ord(char) - 97 - shift) % 26) + 97)\n            decoded_string += decoded_char\n        else:\n            decoded_string += char\n    return decoded_string\n\n# Example inputs and outputs\nexample_input = \"hello\"\nshift = 3\nencoded_output = encode_shift(example_input, shift)\nprint(\"Encoded:\", encoded_output)  # Output: khoor\ndecoded_output = decode_shift(encoded_output, shift)\nprint(\"Decoded:\", decoded_output)  # Output: hello"}
{"task_id": "HumanEval/51", "completion": "VOWELS = 'aeiouAEIOU'\n\ndef remove_vowels(input_text):\n    \"\"\"\n    Removes vowels from the input text.\n\n    Args:\n        input_text (str): The input text from which vowels will be removed.\n\n    Returns:\n        str: The input text with vowels removed.\n        \n    Examples:\n        >>> remove_vowels(\"Hello World\")\n        'Hll Wrld'\n        >>> remove_vowels(\"Python is amazing\")\n        'Pythn s mzng'\n        >>> remove_vowels(\"123!@#\")\n        '123!@#'\n    \"\"\"\n    if not isinstance(input_text, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    return ''.join(char for char in input_text if char not in VOWELS)"}
{"task_id": "HumanEval/52", "completion": "    for num in l:\n        if num >= t:\n            return False\n    return True\n\nprint(below_threshold([1, 2, 4, 10], 100))\nprint(below_threshold([1, 20, 4, 10], 5))"}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int) -> int:\n    \"\"\"\n    Add two numbers.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        int: The sum of x and y.\n\n    Raises:\n        TypeError: If either x or y is not an integer.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both inputs must be integers\")\n    return x + y"}
{"task_id": "HumanEval/54", "completion": "    return sorted(s0) == sorted(s1)"}
{"task_id": "HumanEval/55", "completion": "    if n <= 0:\n        return \"Input number should be positive\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(n - 2):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Check if the given string has correct bracketing.\n\n    Args:\n        brackets (str): A string containing only '<' and '>' brackets.\n\n    Returns:\n        bool: True if the bracketing is correct, False otherwise.\n\n    Examples:\n        >>> correct_bracketing(\"<\")\n        False\n        >>> correct_bracketing(\"<>\")\n        True\n        >>> correct_bracketing(\"<<><>>\")\n        True\n        >>> correct_bracketing(\"><<>\")\n        False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"task_id": "HumanEval/57", "completion": "def is_monotonic(numbers: list[int]) -> bool:\n    \"\"\"\n    Check if the given list is monotonically increasing or decreasing.\n\n    Args:\n        numbers (list[int]): A list of integers.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing,\n        False otherwise.\n\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return numbers == sorted(numbers) or numbers == sorted(numbers, reverse=True)"}
{"task_id": "HumanEval/58", "completion": "def sorted_unique_common_elements(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements between two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A list containing sorted unique common elements.\n    \"\"\"\n    return sorted(set(l1) & set(l2))"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\nprint(largest_prime_factor(13195))\nprint(largest_prime_factor(2048))"}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"\n    Check if the input string contains correctly balanced brackets.\n\n    Args:\n    brackets (str): A string containing only '(' and ')' characters.\n\n    Returns:\n    bool: True if the brackets are correctly balanced, False otherwise.\n\n    Examples:\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack:\n                return False\n            stack.pop()\n        else:\n            # Handling characters other than '(' and ')'\n            raise ValueError(\"Invalid character found in input. Only '(' and ')' characters are allowed.\")\n    if stack:\n        # Unbalanced closing bracket detected\n        raise ValueError(\"Unbalanced closing bracket detected. Missing opening bracket.\")\n    return True"}
{"task_id": "HumanEval/62", "completion": "from typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n    \"\"\"\n    Return the derivative of the polynomial represented by the coefficients in xs.\n\n    Args:\n        xs (List[int]): Coefficients of the polynomial in ascending order of degree.\n\n    Returns:\n        List[int]: Coefficients of the derivative polynomial.\n\n    Raises:\n        ValueError: If the input list is empty or has only one element.\n\n    Examples:\n        >>> derivative([3, 1, 2, 4, 5])\n        [1, 4, 12, 20]\n        >>> derivative([1, 2, 3])\n        [2, 6]\n    \"\"\"\n    if len(xs) <= 1:\n        raise ValueError(\"Input list must have at least two elements to compute the derivative\")\n    \n    return [coef * exp for exp, coef in enumerate(xs[1:], start=1)]"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    \"\"\"\n    Efficiently compute the n-th element of the FibFib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    a, b, c = 0, 0, 1\n    for i in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    return c"}
