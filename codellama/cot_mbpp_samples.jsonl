{"task_id": "MBPP/2", "completion": "\n\n```python\ndef similar_elements(tuple_list1, tuple_list2):\n    set1 = set(tuple_list1)\n    similar = [element for element in tuple_list2 if element in set1]\n    return similar\n```\n\nThis function takes two tuple lists as input and returns a list of elements that are present in both tuple lists. It uses a set to store the elements from the first tuple list for efficient membership testing. The function then uses a list comprehension to iterate through the elements in the second tuple list and only include the elements that are in the set."}
{"task_id": "MBPP/3", "completion": "\n\n```python\nimport math\n\ndef is_not_prime(n):\n    if n == 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(2, math.isqrt(n) + 1):\n        if n % i == 0:\n            return True\n    return False\n```"}
{"task_id": "MBPP/4", "completion": "\n\n```python\nimport heapq\n\ndef n_largest_numbers(lst, n):\n    return heapq.nlargest(n, lst)\n```\n\nThis function uses Python's built-in heapq module, which provides an implementation of the heap queue algorithm, to find the n largest integers from a given list of numbers. The heapq.nlargest function does exactly what we need: it returns the n largest elements from the list in descending order."}
{"task_id": "MBPP/6", "completion": "\n\n```python\ndef is_One_Bit_Difference(x, y):\n    # Convert the numbers to binary representation\n    x_bin = bin(x)\n    y_bin = bin(y)\n\n    # Compare the binary representation\n    if len(x_bin) != len(y_bin):\n        return False\n\n    # Count the number of differing bit positions\n    diff_count = 0\n    for i in range(2, len(x_bin)):\n        if x_bin[i] != y_bin[i]:\n            diff_count += 1\n\n    # Check if the count is exactly 1\n    if diff_count == 1:\n        return True\n    else:\n        return False\n```"}
{"task_id": "MBPP/7", "completion": "\n\n```python\nimport re\n\ndef find_char_long(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n\n# Test the function\ntext = \"hello world, python is a great programming language.\"\nprint(find_char_long(text))\n```"}
{"task_id": "MBPP/8", "completion": "\n\n```python\ndef square_nums(nums):\n    return list(map(lambda x: x**2, nums))\n```"}
{"task_id": "MBPP/9", "completion": "\n\n```python\ndef min_rotations(str):\n    index_dict = {}\n    for i in range(len(str)):\n        if str[i] in index_dict:\n            return i - index_dict[str[i]]\n        else:\n            index_dict[str[i]] = i\n    return -1\n```"}
{"task_id": "MBPP/11", "completion": "\n\n```python\ndef remove_chars(s, ch):\n    if len(s) == 0 or s[0] != ch:\n        result = s\n    else:\n        result = s[1:]\n\n    result = ch.join([word for word in result.split(ch) if word])\n\n    if result.endswith(ch):\n        result = result[:-1]\n\n    return result\n```"}
{"task_id": "MBPP/12", "completion": "\n\n```python\ndef sort_matrix(M):\n    row_sums = [(row, sum(row)) for row in M]\n    row_sums = sorted(row_sums, key=lambda x: x[1])\n    sorted_matrix = [row for row, _ in row_sums]\n    return sorted_matrix\n```"}
{"task_id": "MBPP/14", "completion": "\n\n```python\ndef volume_of_triangular_prism(l, b, h):\n    area_of_triangle = 0.5 * l * b\n    volume = area_of_triangle * h\n    return volume\n```"}
{"task_id": "MBPP/16", "completion": "\n\n```python\nimport re\n\ndef text_lowercase_underscore(text):\n    pattern = r\"[a-z]+(_[a-z]+)*\"\n    result = re.findall(pattern, text)\n    return result\n```"}
{"task_id": "MBPP/17", "completion": "\n\n```python\ndef square_perimeter(side_length):\n    if side_length <= 0:\n        return \"Error: The side length should be a positive number.\"\n    else:\n        return 4 * side_length\n```"}
{"task_id": "MBPP/18", "completion": "\n\n```python\ndef str_to_list(string):\n    res = [0] * 256\n    for i in string:\n        res[ord(i)] += 1\n    return res\n\ndef remove_chars(str1, str2):\n    str2_list = str_to_list(str2)\n    res = \"\"\n    for i in str1:\n        if str2_list[ord(i)] == 0:\n            res += i\n    return res\n```"}
{"task_id": "MBPP/19", "completion": "\n\n```python\ndef has_duplicate(arraynums):\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        else:\n            seen.add(num)\n    return False\n```"}
{"task_id": "MBPP/20", "completion": "\n\n```python\ndef is_woodall(x):\n    sum_of_digits = 0\n    for digit in str(x):\n        sum_of_digits += int(digit)\n    while sum_of_digits % 2 == 0:\n        sum_of_digits /= 2\n    return sum_of_digits == 1\n```"}
{"task_id": "MBPP/56", "completion": "\n\n```python\ndef is_one_less_than_twice_reverse(num):\n    num_str = str(num)\n    reversed_str = num_str[::-1]\n    reversed_num = int(reversed_str)\n    return num == 2 * reversed_num - 1\n```"}
{"task_id": "MBPP/57", "completion": "\n\n```python\ndef find_Max_Num(arr): \n    all_nums = []\n    def generate_nums(current_num, remaining_digits):\n        if len(remaining_digits) == 0:\n            all_nums.append(int(current_num))\n            return\n        for i in range(len(remaining_digits)):\n            generate_nums(current_num + str(remaining_digits[i]), remaining_digits[:i] + remaining_digits[i+1:])\n    generate_nums(\"\", arr)\n    all_nums.sort(reverse=True)\n    return all_nums[0]\n```\n\nThis function takes a list of digits as input and returns the largest number that can be formed with those digits. The function generates all possible numbers using the given digits, sorts them in descending order, and then returns the first number in the sorted list, which is the largest number."}
{"task_id": "MBPP/58", "completion": "\n\n```python\ndef check_opposite_sign(a, b):\n    result = False\n    if a == 0 or b == 0:\n        return False\n    else:\n        if (a > 0 and b < 0) or (a < 0 and b > 0):\n            result = True\n    return result\n```"}
{"task_id": "MBPP/59", "completion": "\n\n```python\ndef nth_octagonal(n):\n    if n < 1:\n        return \"Error: Input must be a positive integer.\"\n    else:\n        return n * (3 * n - 2)\n```"}
{"task_id": "MBPP/61", "completion": "\n\n```python\nfrom collections import defaultdict\n\ndef count_Substrings(s, n):\n    count = 0\n    dp = defaultdict(int)\n    dp[0] = 1\n    sum = 0\n    for i in range(n):\n        sum += int(s[i])\n        if (sum - n + i + 1) >= 0:\n            count += dp[sum - n + i + 1]\n        dp[sum] += 1\n    return count\n\ns = \"123\"\nn = len(s)\nprint(count_Substrings(s,n))\n```"}
{"task_id": "MBPP/62", "completion": "\n\n```python\ndef find_smallest_number(lst):\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest\n```"}
{"task_id": "MBPP/63", "completion": "\n\n```python\ndef max_diff(test_list):\n    max_diff = 0\n    min_element = test_list[0]\n    for i in range(1, len(test_list)):\n        if test_list[i] < min_element:\n            min_element = test_list[i]\n        elif test_list[i] - min_element > max_diff:\n            max_diff = test_list[i] - min_element\n    return max_diff\n```"}
{"task_id": "MBPP/64", "completion": "\n\n```python\ndef subject_marks(subjectmarks):\n    return sorted(subjectmarks, key=lambda x: x[1])\n```"}
{"task_id": "MBPP/65", "completion": "\n\n```python\ndef sum_list(data_list):\n    if not isinstance(data_list, list):\n        return data_list\n    elif len(data_list) == 0:\n        return 0\n    else:\n        return data_list[0] + sum_list(data_list[1:])\n```\n\nThis function works by recursively breaking down the list into its first element and the rest of the list, summing the first element with the sum of the rest of the list, until there are no more elements left, at which point it returns 0."}
{"task_id": "MBPP/66", "completion": "\n\n```python\ndef count_positive_numbers(list):\n    counter = 0\n    for num in list:\n        if num > 0:\n            counter += 1\n    return counter\n```"}
{"task_id": "MBPP/67", "completion": "\n\n```python\ndef number_of_ways(n):\n    bell_number = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        bell_number[i][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            bell_number[i][j] = bell_number[i-1][j-1] + bell_number[i-1][j]\n    return bell_number[n][n]\n```"}
{"task_id": "MBPP/68", "completion": "\n\n```python\ndef is_monotonic(A):\n    increasing = decreasing = True\n    for i in range(len(A) - 1):\n        if A[i] > A[i + 1]:\n            increasing = False\n        elif A[i] < A[i + 1]:\n            decreasing = False\n    return increasing or decreasing\n```"}
{"task_id": "MBPP/69", "completion": "\n\n```python\ndef contains_sublist(l, s):\n    pos = 0\n    for i in l:\n        if i == s[0]:\n            if l[pos:pos+len(s)] == s:\n                return True\n        pos += 1\n    return False\n```"}
{"task_id": "MBPP/70", "completion": "\n\n```python\ndef all_equal_length(tuples):\n    if not tuples:\n        return True\n    len_first = len(tuples[0])\n    for t in tuples:\n        if len(t) != len_first:\n            return False\n    return True\n```\n\nThis function takes a list of tuples as input and returns True if all the tuples have equal lengths, and False otherwise. If the input list is empty, it also returns True."}
{"task_id": "MBPP/71", "completion": "\n\n```python\ndef comb_sort(nums):\n    gap = len(nums)\n    while gap > 1:\n        gap = gap // 1.3\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n    for i in range(len(nums) - 1):\n        for j in range(len(nums) - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n```"}
{"task_id": "MBPP/72", "completion": "\n\n```python\ndef is_difference_of_squares(n):\n    squares = {i**2 for i in range(int(n**0.5) + 1)}\n    return n in squares or any(n - x in squares for x in squares)\n```"}
{"task_id": "MBPP/74", "completion": "\n\n```python\ndef check_color_sequence(colors, patterns):\n    current_color = colors[0]\n    for pattern in patterns:\n        if current_color not in pattern:\n            return False\n        current_color = pattern[pattern.index(current_color) + 1]\n    return True\n```"}
{"task_id": "MBPP/75", "completion": "\n\n```python\ndef find_divisible_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        flag = True\n        for elem in tup:\n            if elem % K != 0:\n                flag = False\n                break\n        if flag:\n            result.append(tup)\n    return result\n```"}
{"task_id": "MBPP/77", "completion": "\n\n```python\ndef find_difference(n):\n    even_sum = 0\n    odd_sum = 0\n    str_n = str(n)\n    for digit in str_n:\n        int_digit = int(digit)\n        if int_digit % 2 == 0:\n            even_sum += int_digit\n        else:\n            odd_sum += int_digit\n    return even_sum - odd_sum\n```"}
{"task_id": "MBPP/79", "completion": "\n\n```python\ndef first_repeated_char(word):\n    seen = set()\n    for char in word:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n\n# Test the function\nprint(first_repeated_char(\"hello\"))  # Output: 'l'\nprint(first_repeated_char(\"world\"))  # Output: 'w'\nprint(first_repeated_char(\"python\"))  # Output: 'p'\nprint(first_repeated_char(\"apple\"))  # Output: 'p'\nprint(first_repeated_char(\"banana\"))  # Output: 'a'\n```"}
{"task_id": "MBPP/80", "completion": "\n\n```python\ndef tetrahedral_number(n):\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return n * (n + 1) * (n + 2) // 6\n```"}
{"task_id": "MBPP/82", "completion": "\n\n```python\nimport math\n\ndef volume_of_sphere(r):\n    return (4/3) * math.pi * r**3\n```"}
{"task_id": "MBPP/83", "completion": "\n\n```python\ndef add_chars(strr):\n    result = \"\"\n    for char in strr:\n        result += chr(ord(char) + 1)\n    return result\n```"}
{"task_id": "MBPP/84", "completion": "\n\n```python\ndef newman_conway(n):\n    # Step 1: Initialize sequence\n    sequence = [1, 1]\n\n    # Step 2: Iterate from 3 to n\n    for i in range(2, n):\n        # Step 3: Calculate parent numbers\n        parent1 = sequence[sequence[i-1]-1]\n        parent2 = sequence[sequence[i-2]-1]\n\n        # Step 4: Find parent values in sequence\n        parent_value = parent1 + parent2\n\n        # Step 5: Add to sequence\n        sequence.append(parent_value)\n\n    # Step 6: Return n-th number\n    return sequence[n-1]\n```"}
{"task_id": "MBPP/85", "completion": "\n\n```python\nimport math\n\ndef sphere_surface_area(r):\n    return 4 * math.pi * r ** 2\n```"}
{"task_id": "MBPP/86", "completion": "\n\n```python\ndef nth_centered_hexagonal(n):\n    if n <= 0:\n        return 0\n    else:\n        return n * (2*n - 1)\n```"}
{"task_id": "MBPP/87", "completion": "\n\n```python\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for d in [dict1, dict2, dict3]:\n        merged_dict.update(d)\n    return merged_dict\n```"}
{"task_id": "MBPP/88", "completion": "\n\n```python\nfrom collections import Counter\n\ndef freq_count(list1):\n    return Counter(list1)\n```"}
{"task_id": "MBPP/89", "completion": "\n\n```python\ndef closest_num(N):\n    smaller_nums = [num for num in range(0, N) if num < N]\n    return max(smaller_nums)\n```"}
{"task_id": "MBPP/90", "completion": "\n\n```python\ndef longest_word_length(list1):\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n```"}
{"task_id": "MBPP/91", "completion": "\n\n```python\ndef is_substring_in_list(str1, sub_str):\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False\n```"}
{"task_id": "MBPP/92", "completion": "\n\n```python\ndef is_undulating(n):\n    n = str(n)\n    for i in range(len(n) - 1):\n        if abs(int(n[i]) - int(n[i+1])) > 1:\n            return False\n    return True\n```\n\nThis function takes an integer `n` as input, converts it to a string, and then iterates through the string, comparing each digit to the next one. If the difference between any two consecutive digits is greater than 1, the function returns `False`. If the loop finishes without returning `False`, the function returns `True`, indicating that `n` is an undulating number."}
{"task_id": "MBPP/93", "completion": "\n\n```python\ndef power(a, b):\n    result = 1\n    if b == 0:\n        return 1\n    elif b < 0:\n        a = 1/a\n        b = abs(b)\n    for _ in range(b):\n        result *= a\n    return result\n```"}
{"task_id": "MBPP/94", "completion": "\n\n```python\ndef min_tuple(test_list, index):\n    min_value = float('inf')\n    min_index = None\n    for i, tup in enumerate(test_list):\n        value = tup[index]\n        if value < min_value:\n            min_value = value\n            min_index = i\n    return test_list[min_index]\n```"}
{"task_id": "MBPP/95", "completion": "\n\n```python\ndef min_sublist_length(lst):\n    return min(len(sublist) for sublist in lst)\n```"}
{"task_id": "MBPP/96", "completion": "\n\n```python\ndef count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/97", "completion": "\n\n```python\ndef find_frequency(list1):\n    freq_count = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in freq_count:\n            freq_count[sublist_tuple] += 1\n        else:\n            freq_count[sublist_tuple] = 1\n    return freq_count\n```"}
{"task_id": "MBPP/98", "completion": "\n\n```python\ndef avg_product(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n```"}
{"task_id": "MBPP/99", "completion": "\n\n```python\ndef decimal_to_binary(n):\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return int(binary)\n```"}
{"task_id": "MBPP/100", "completion": "\n\n```python\ndef next_smallest_palindrome(n):\n    n += 1\n    while True:\n        str_n = str(n)\n        mid = len(str_n) // 2\n        if str_n[:mid] == str_n[mid:][::-1]:\n            return n\n        n += 1\n    return None\n```"}
{"task_id": "MBPP/101", "completion": "\n\n```python\ndef find_kth_element(arr, n, k):\n    if k < 0 or k >= n:\n        return None\n    else:\n        return arr[k]\n```"}
{"task_id": "MBPP/102", "completion": "\n\n```python\ndef snake_to_camel(word):\n    return ''.join(w.capitalize() if i > 0 else w for i, w in enumerate(word.split('_')))\n```"}
{"task_id": "MBPP/103", "completion": "\n\n```python\ndef eulerian_number(n, m):\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, min(i, m)+1):\n            if j % 2 == 0:\n                dp[i][j] = dp[i][j-1] + dp[i-1][j//2-1] if j//2-1 >= 0 else dp[i-1][0]\n    return dp[n][m]\n```\n\nThis function calculates the Eulerian number a(n, m) using dynamic programming. The time complexity is O(n*m), and the space complexity is O(n*m), due to the 2D dp array."}
{"task_id": "MBPP/104", "completion": "\n\n```python\ndef sort_sublist(lst):\n    return [sorted(sublist, key=lambda x: len(x)) for sublist in lst]\n```\n\nThis function uses a list comprehension to iterate through each sublist in the input list. The `sorted()` function is used with a lambda function to sort the strings in each sublist based on their length. The sorted sublists are then returned in a new list."}
{"task_id": "MBPP/105", "completion": "\n\n```python\ndef count_true(lst):\n    return sum(1 for element in lst if element)\n```"}
{"task_id": "MBPP/106", "completion": "\n\n```python\ndef add_lists(test_list, test_tup):\n    new_tup = []\n    for i in test_tup:\n        new_tup.append(i + test_list)\n    return tuple(new_tup)\n```"}
{"task_id": "MBPP/108", "completion": "\n\n```python\nimport heapq\n\ndef merge_sorted_lists(num1, num2, num3):\n    sorted_iterator = []\n    heapq.heapify(num1)\n    heapq.heapify(num2)\n    heapq.heapify(num3)\n    while num1 or num2 or num3:\n        if num1:\n            sorted_iterator.append(heapq.heappop(num1))\n        if num2:\n            sorted_iterator.append(heapq.heappop(num2))\n        if num3:\n            sorted_iterator.append(heapq.heappop(num3))\n    return sorted_iterator\n```"}
{"task_id": "MBPP/109", "completion": "\n\n```python\ndef count_rotations(s):\n    seen = set()\n    count = 0\n    for rotation in generate_all_rotations(s):\n        binary_string = convert_to_binary_string(rotation)\n        if len(binary_string) % 2 == 0:\n            if binary_string not in seen:\n                seen.add(binary_string)\n                if int(binary_string, 2) % 2 == 1:\n                    count += 1\n    return count\n```\n\nNote: `generate_all_rotations` and `convert_to_binary_string` are helper functions that need to be implemented based on the problem's specifications."}
{"task_id": "MBPP/111", "completion": "\n\n```python\ndef flatten(nested_list):\n    flattened = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened.extend(flatten(item))\n        else:\n            flattened.append(item)\n    return flattened\n\ndef common_in_nested_lists(nested_list):\n    common_elements = set()\n    flattened_list = flatten(nested_list)\n    for element in flattened_list:\n        if element in common_elements:\n            continue\n        else:\n            common_elements.add(element)\n    return common_elements\n```"}
{"task_id": "MBPP/113", "completion": "\n\n```python\ndef is_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n```"}
{"task_id": "MBPP/115", "completion": "\n\n```python\ndef all_empty(list1):\n    all_empty = True\n    for dic in list1:\n        if dic:\n            all_empty = False\n            break\n    return all_empty\n```"}
{"task_id": "MBPP/116", "completion": "\n\n```python\ndef convert_tuple_to_int(tup):\n    return int(''.join(map(str, tup)))\n```"}
{"task_id": "MBPP/117", "completion": "\n\n```python\ndef convert_to_float(test_list):\n    converted_list = []\n    for element in test_list:\n        try:\n            float_element = float(element)\n            converted_list.append(float_element)\n        except ValueError:\n            converted_list.append(element)\n    return converted_list\n```"}
{"task_id": "MBPP/118", "completion": "\n\n```python\ndef string_to_list(string):\n    return list(string)\n```"}
{"task_id": "MBPP/119", "completion": "\n\n```python\ndef find_unique(arr):\n    if not arr:\n        return None\n\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    for num, count in count_dict.items():\n        if count == 1:\n            return num\n\n    return None\n```"}
{"task_id": "MBPP/120", "completion": "\n\n```python\ndef max_product(list1):\n    max_product = 0\n    for i in range(len(list1)):\n        max_product = max(max_product, list1[i][0] * list1[i][1])\n    return max_product\n```"}
{"task_id": "MBPP/123", "completion": "\n\n```python\ndef amicable_numbers(limit):\n    sum_of_divisors = {}\n\n    def calculate_sum_of_divisors(num):\n        sum = 0\n        for i in range(1, num // 2 + 1):\n            if num % i == 0:\n                sum += i\n        return sum\n\n    for num in range(1, limit + 1):\n        sum_of_divisors[num] = calculate_sum_of_divisors(num)\n\n    sum_of_amicable_numbers = 0\n\n    for num in sum_of_divisors:\n        if sum_of_divisors[num] != num and sum_of_divisors[sum_of_divisors[num]] == num:\n            sum_of_amicable_numbers += num\n\n    return sum_of_amicable_numbers\n```"}
{"task_id": "MBPP/124", "completion": "\n\n```python\nimport cmath\n\ndef angle_complex(a, b):\n    c_num = complex(a, b)\n    radians = cmath.phase(c_num)\n    degrees = radians * (180.0 / cmath.pi)\n    return degrees\n```"}
{"task_id": "MBPP/125", "completion": "\n\n```python\ndef max_diff(string):\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n\n    for i in range(len(string)):\n        if string[i] == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n\n    max_diff = max(max_diff, abs(count_0 - count_1))\n\n    return max_diff\n```"}
{"task_id": "MBPP/126", "completion": "\n\n```python\ndef sum_common_divisors(a, b):\n    common_divisors = set()\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.add(i)\n    return sum(common_divisors)\n```"}
{"task_id": "MBPP/127", "completion": "\n\n```python\ndef multiply(x, y):\n    result = 0\n    for _ in range(abs(y)):\n        result += x\n    if y < 0:\n        result = -result\n    return result\n```"}
{"task_id": "MBPP/128", "completion": "\n\n```python\ndef long_words(words, n):\n    return [word for word in words if len(word) > n]\n```"}
{"task_id": "MBPP/129", "completion": "\n\n```python\ndef calculate_magic_square(n):\n    magic_square = [[0 for i in range(n)] for j in range(n)]\n    num = 1\n    i = n // 2\n    j = n - 1\n\n    while num <= n * n:\n        if i < 0 or j < 0 or i >= n or j >= n or magic_square[i][j] != 0:\n            if j == n - 1:\n                j = n - 2\n            else:\n                j = 0\n            i += 1\n        else:\n            magic_square[i][j] = num\n            num += 1\n\n        i -= 1\n        j += 1\n\n    return magic_square"}
{"task_id": "MBPP/130", "completion": "\n\n```python\nfrom collections import defaultdict\n\ndef max_occurrences(nums):\n    freq_dict = defaultdict(int)\n    for num in nums:\n        freq_dict[num] += 1\n\n    max_item = None\n    max_freq = 0\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    return max_item\n```"}
{"task_id": "MBPP/131", "completion": "\n\n```python\ndef reverse_vowels(str1):\n    vowels = []\n    for char in str1:\n        if char.lower() in 'aeiou':\n            vowels.append(char)\n    vowels = vowels[::-1]\n    result = ''\n    for char in str1:\n        if char.lower() in 'aeiou':\n            result += vowels.pop()\n        else:\n            result += char\n    return result\n```"}
{"task_id": "MBPP/132", "completion": "\n\n```python\ndef tup_string(tup1):\n    str1 = ''\n    for i in tup1:\n        if isinstance(i, tuple):\n            str1 += tup_string(i)\n        elif isinstance(i, str):\n            str1 += i\n        else:\n            str1 += str(i)\n    return str1\n\nprint(tup_string(('Hello', 'World', (1, 2, ('Nested', 'Tuple')))))\n```"}
{"task_id": "MBPP/133", "completion": "\n\n```python\ndef sum_negativenum(nums):\n    return sum(filter(lambda x: x < 0, nums))\n```"}
{"task_id": "MBPP/135", "completion": "\n\n```python\ndef hexagonal_num(n):\n    return n * (2 * n - 1)\n```"}
{"task_id": "MBPP/137", "completion": "\n\n```python\ndef zero_ratio(nums):\n    zero_count = 0\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    zero_ratio = zero_count / len(nums)\n    return zero_ratio\n```"}
{"task_id": "MBPP/138", "completion": "\n\n```python\ndef is_Sum_Of_Powers_Of_Two(n):\n    current_sum = n\n    i = 1\n    while current_sum > 0:\n        current_power = 2 ** i\n        if current_power > current_sum:\n            break\n        if current_sum - current_power >= 0:\n            current_sum -= current_power\n        else:\n            break\n        if current_sum == 0:\n            return True\n        i += 1\n    return False\n```"}
{"task_id": "MBPP/139", "completion": "\n\n    ```python\n    import math\n\n    def calculate_circumference(r):\n        circumference = 2 * math.pi * r\n        return circumference\n    ```\n\n    This function can be used to calculate the circumference of a circle with a given radius. For example, to calculate the circumference of a circle with a radius of 5, you would use:\n\n    ```python\n    circumference = calculate_circumference(5)\n    print(circumference)\n    ```\n\n    This would output: 31.41592653589793"}
{"task_id": "MBPP/140", "completion": "\n\n```python\ndef extract_singly(test_list):\n    count_dict = {}\n    for tup in test_list:\n        for elem in tup:\n            if elem in count_dict:\n                count_dict[elem] += 1\n            else:\n                count_dict[elem] = 1\n\n    singly_list = []\n    for elem, count in count_dict.items():\n        if count == 1:\n            singly_list.append(elem)\n\n    return singly_list\n\ntest_list = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (6, 7, 8), (7, 8, 9), (8, 9, 10), (9, 10, 1), (10, 1, 2)]\nprint(extract_singly(test_list))\n```"}
{"task_id": "MBPP/141", "completion": "\n\n```python\ndef pancake_sort(arr):\n    n = len(arr)\n \n    # Iterate over all elements in array\n    for i in range(n, 0, -1):\n        # Find index of the maximum element\n        max_idx = arr.index(max(arr[:i]))\n \n        # If maximum element is not at the end of array, move it to end by flipping\n        if max_idx != i-1:\n            arr[:i] = arr[max_idx:i][::-1] + arr[max_idx+1:i]\n \n        # Reverse the elements so far\n        arr[:i] = arr[:i][::-1]\n \n    return arr\n```\n\nThis function takes a list of numbers as input and returns the sorted list. It uses the pancake sort algorithm to sort the list. The algorithm works by finding the maximum element and moving it to its correct position in the sorted list, then reversing the list so far, and repeating this process until all elements are in their correct positions. The function uses a for loop to iterate over the list, and a conditional statement to check if the maximum element is not at the end of the list, in which case it flips the list around this element. The function also uses the built-in Python function max() to find the maximum element and the built-in function index() to find the index of the maximum element. The function returns the sorted list."}
{"task_id": "MBPP/142", "completion": "\n\n```python\ndef count_same_pairs(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)-1):\n        pair = (list1[i], list1[i+1])\n        if pair in list2 and pair in list3:\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/143", "completion": "\n\n```python\ndef count_lists(Input):\n    count = 0\n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/145", "completion": "\n\n```python\ndef max_diff(arr):\n    max_diff = None\n    min_element = None\n\n    for element in arr:\n        if min_element is None:\n            min_element = element\n        else:\n            if max_diff is None or element - min_element > max_diff:\n                max_diff = element - min_element\n\n    return max_diff if max_diff is not None else 0\n```"}
{"task_id": "MBPP/160", "completion": "\n\n```python\ndef find_solution(a, b, n):\n    x, y = 0, 0\n    while True:\n        if a*x + b*y == n:\n            return (x, y)\n        x += 1\n        if a*x + b*y == n:\n            return (x, y)\n        y = (n - a*x) / b\n        if a*x + b*y == n:\n            return (x, y)\n        x, y = 0, y+1\n        if y == n/b:\n            return None\n```\n\nNote: This code assumes that `a` and `b` are positive integers and `n` is a non-negative integer. If these assumptions are not met, the code may not work correctly."}
{"task_id": "MBPP/161", "completion": "\n\n```python\ndef remove_elements(list1, list2):\n    result = []\n    for element in list1:\n        if element not in list2:\n            result.append(element)\n    return result\n```"}
{"task_id": "MBPP/162", "completion": "\n\nHere is the Python code:\n\n```python\ndef sum_series(n):\n    sum = 0\n    for i in range(n, 0, -2):\n        sum += i\n    return sum\n```"}
{"task_id": "MBPP/164", "completion": "\n\n```python\nimport math\n\ndef divSum(n):\n    sum1 = 0\n    for i in range(1, math.isqrt(n) + 1):\n        if n % i == 0:\n            sum1 += i\n            if i != n // i:\n                sum1 += n // i\n    return sum1\n\ndef checkDivisorsSum(n):\n    sum1 = divSum(n)\n    sum2 = n - sum1\n    if sum1 == sum2:\n        return True\n    else:\n        return False\n```"}
{"task_id": "MBPP/165", "completion": "\n\n```python\ndef count_chars(str1):\n    count_dict = {}\n    for i in range(len(str1)):\n        char = str1[i].lower()\n        if char.isalpha():\n            pos = ord(char) - ord('a') + 1\n            if pos not in count_dict:\n                count_dict[pos] = 0\n            count_dict[pos] += 1\n    return count_dict\n```"}
{"task_id": "MBPP/166", "completion": "\n\n```python\ndef count_pairs_with_even_xor(A):\n    bit_count = {i: [0, 0] for i in range(32)}\n    for num in A:\n        for i in range(32):\n            bit_count[i][num & 1] += 1\n            num >>= 1\n    even_pairs = 0\n    for count0, count1 in bit_count.values():\n        even_pairs += count0 * count1\n    return even_pairs\n```"}
{"task_id": "MBPP/167", "completion": "\n\n```python\ndef smallest_power_of_two(n):\n    result = 1\n    while result < n:\n        result *= 2\n    return result\n```"}
{"task_id": "MBPP/168", "completion": "\n\n```python\ndef frequency(a, x):\n    count = 0\n    for i in a:\n        if i == x:\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/170", "completion": "\n\nHere is the Python code:\n\n```python\ndef sum_range_list(list1, m, n):\n    return sum(list1[m:n+1])\n```\n\nThis function uses Python's built-in `sum()` function to add up all the elements in the specified range of `list1`. The range is defined by slicing the list from index `m` to `n+1` (because the end index in a slice is exclusive). The sum is then returned as the result."}
{"task_id": "MBPP/171", "completion": "\n\n```python\ndef perimeter_pentagon(a):\n    # The perimeter of a pentagon is calculated by the formula: 5 * side\n    perimeter = 5 * a\n    return perimeter\n\n# Test the function\nprint(perimeter_pentagon(4)) # The output should be 20\n```"}
{"task_id": "MBPP/172", "completion": "\n\n```python\ndef count_std(string):\n    count_dict = {'s': 0, 't': 0, 'd': 0}\n    for char in string:\n        if char in count_dict:\n            count_dict[char] += 1\n    return count_dict\n```"}
{"task_id": "MBPP/222", "completion": "\n\n```python\ndef check_same_type(test_tuple):\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True\n```"}
{"task_id": "MBPP/223", "completion": "\n\n```python\ndef is_majority(arr, x):\n    n = len(arr)\n    start = 0\n    end = 0\n    for i in range(n):\n        if arr[i] == x:\n            end += 1\n        else:\n            start += 1\n            end += 1\n        if end - start + 1 > n // 2:\n            return True\n    return False\n```\n\nThis function checks if an element `x` is a majority element in a sorted array `arr`. It does this by maintaining a \"window\" of elements in `arr` that are the same as `x` and moving this window through the array. If the window's size is more than half the size of the array, then `x` is a majority element."}
{"task_id": "MBPP/224", "completion": "\n\n```python\ndef count_Set_Bits(n):\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count\n```"}
{"task_id": "MBPP/226", "completion": "\n\n```python\ndef odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result\n\nprint(odd_values_string(\"Hello, World!\")) # Expected output: \"HloWrd!\"\n```"}
{"task_id": "MBPP/227", "completion": "\n\n```python\ndef find_minimum(a, b, c):\n    min_val = a\n    if b < min_val:\n        min_val = b\n    if c < min_val:\n        min_val = c\n    return min_val\n```\n\nThis function takes three numbers as input and returns the minimum value. It uses the basic structures of sequences (list of arguments), branches (if statements), and loops (not applicable in this case) to solve the problem."}
{"task_id": "MBPP/229", "completion": "\n\n```python\ndef re_arrange_array(arr):\n    return [num for num in arr if num < 0] + [num for num in arr if num >= 0]\n```\n\nThis is a more Pythonic way to solve the problem using list comprehensions. It does the same thing as the previous function: it creates two lists, one for negative numbers and one for positive numbers, and then concatenates them. The list comprehensions work by iterating through the given array and including each number in the appropriate list based on whether it's less than or greater than or equal to zero."}
{"task_id": "MBPP/230", "completion": "\n\n```python\ndef replace_spaces(s, char):\n    result = \"\"\n    for c in s:\n        if c == \" \":\n            result += char\n        else:\n            result += c\n    return result\n```\n\nThis function takes two arguments: the input string `s` and the character `char` to replace spaces with. It initializes an empty string `result` to store the output. Then, it iterates through each character in the input string. If the character is a space, it appends `char` to `result`. If the character is not a space, it appends the original character to `result`. Finally, it returns `result`."}
{"task_id": "MBPP/232", "completion": "\n\n```python\nimport heapq\n\ndef get_n_largest_items(n, list1):\n    return heapq.nlargest(n, list1)\n```"}
{"task_id": "MBPP/233", "completion": "\n\n```python\nimport math\n\ndef lateralsuface_cylinder(r, h):\n    return 2 * math.pi * r * h\n```"}
{"task_id": "MBPP/234", "completion": "\n\n```python\ndef volume_of_cube(side_length):\n    if side_length > 0:\n        return side_length ** 3\n    else:\n        return None\n```\n\nThis function takes a single argument, `side_length`, which represents the length of a side of the cube. If `side_length` is a positive number, the function calculates and returns the volume of the cube. If `side_length` is not a positive number, the function returns `None` to indicate an error."}
{"task_id": "MBPP/235", "completion": "\n\n```python\ndef set_even_bits(num):\n    return num | 0x55555555\n```\n\nThis function works by setting all the even bits of the given number. The `0x55555555` is a 32-bit number where all even bits are set. When we perform a bitwise OR operation with this number, all even bits of the given number are set.\n\nFor example, if the input number is `0x12345678`, after the operation, the number becomes `0x52345678`, where all even bits are set."}
{"task_id": "MBPP/237", "completion": "\n\n```python\nfrom collections import Counter\n\ndef check_occurences(test_list):\n    counter_obj = Counter()\n    for tup in test_list:\n        counter_obj.update(tup)\n    result = {k: v for k, v in counter_obj.items() if v >= 2}\n    return result\n```"}
{"task_id": "MBPP/238", "completion": "\n\n```python\ndef count_non_empty_substrings(str):\n    counter = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            if str[i:j] != '':\n                counter += 1\n    return counter\n```"}
{"task_id": "MBPP/239", "completion": "\n\n```python\ndef num_of_sequences(n, m):\n    def recurse(start, length, max_val):\n        if length == 0:\n            return 1\n        total = 0\n        for i in range(start, max_val + 1):\n            total += recurse(i * 2, length - 1, max_val)\n        return total\n\n    total = 0\n    for i in range(1, m // 2 + 1):\n        total += recurse(i, n, m)\n    return total\n```"}
{"task_id": "MBPP/240", "completion": "\n\n```python\ndef replace_last_element(lst, new_lst):\n    if len(lst) < 2:\n        return lst\n    else:\n        lst[-1] = new_lst\n        return lst\n```\n\nThis function takes two arguments: a list `lst` and a list `new_lst`. It checks if `lst` has less than two elements. If it does, the function returns `lst` as is. Otherwise, it replaces the last element of `lst` with `new_lst` and returns the modified list."}
{"task_id": "MBPP/242", "completion": "\n\n```python\ndef count_charac(str1):\n    count = 0\n    for char in str1:\n        count += 1\n    return count\n\nprint(count_charac(\"Hello, World!\")) # Output: 13\n```"}
{"task_id": "MBPP/244", "completion": "\n\n```python\nimport math\n\ndef next_perfect_square(N):\n    sqrt = math.sqrt(N)\n    if sqrt.is_integer():\n        return (sqrt + 1) ** 2\n    else:\n        return (math.ceil(sqrt) + 1) ** 2\n```"}
{"task_id": "MBPP/245", "completion": "\n\n```python\ndef max_sum_bitonic(arr):\n    max_sum = float('-inf')\n    curr_inc_sum = 0\n    curr_dec_sum = 0\n\n    for i in range(len(arr)):\n        if i > 0 and arr[i] > arr[i - 1]:\n            curr_inc_sum += arr[i]\n        elif i > 0 and arr[i] < arr[i - 1]:\n            curr_dec_sum += arr[i]\n        else:\n            continue\n\n        if curr_dec_sum > curr_inc_sum:\n            curr_inc_sum, curr_dec_sum = curr_dec_sum, curr_inc_sum\n\n        max_sum = max(max_sum, curr_inc_sum + curr_dec_sum)\n\n    return max_sum\n```"}
{"task_id": "MBPP/247", "completion": "\n\n```python\ndef longest_palindromic_subsequence(str):\n    n = len(str)\n    lps_array = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        lps_array[i][i] = 1\n\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str[i] == str[j] and cl == 2:\n                lps_array[i][j] = 2\n            elif str[i] == str[j]:\n                lps_array[i][j] = lps_array[i + 1][j - 1] + 2\n            else:\n                lps_array[i][j] = max(lps_array[i][j - 1], lps_array[i + 1][j])\n\n    return lps_array[0][n - 1]\n```\n\nThis function takes a string as input and returns the length of the longest palindromic subsequence in the string."}
{"task_id": "MBPP/249", "completion": "\n\n```python\ndef array_intersection(arr1, arr2):\n    return list(set(arr1).intersection(arr2))\n```\n\nThis function takes two arrays as input and returns a list of their intersection. It first converts the arrays to sets, finds the intersection of the two sets, and then converts the resultant set back into a list.\n\nExample usage:\n\n```python\nprint(array_intersection([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]))  # Output: [4, 5]\n```"}
{"task_id": "MBPP/250", "completion": "\n\n```python\ndef count_X(tup, x):\n    count = 0\n    for i in tup:\n        if i == x:\n            count += 1\n    return count\n\ntup = (1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2)\nx = 2\nprint(count_X(tup, x))  # Output: 5\n```"}
{"task_id": "MBPP/251", "completion": "\n\n```python\ndef insert_element(list, element):\n    return [[element, i] for i in list]\n```"}
{"task_id": "MBPP/252", "completion": ""}
{"task_id": "MBPP/253", "completion": "\n\n```python\ndef count_integer(list1):\n    counter = 0\n    for element in list1:\n        if isinstance(element, int):\n            counter += 1\n    return counter\n\nlist1 = [1, 2, 'a', 3.5, 4, 'b', 5, 6.7, 'c']\nprint(count_integer(list1))  # Output: 6\n```"}
{"task_id": "MBPP/255", "completion": "\n\n```python\nfrom itertools import combinations_with_replacement\n\ndef generate_combinations(l, n):\n    combinations = []\n    for combo in combinations_with_replacement(l, n):\n        combinations.append(combo)\n    return combinations\n```"}
{"task_id": "MBPP/256", "completion": "\n\n```python\ndef count_primes(n):\n    counter = 0\n    for num in range(2, n):\n        if is_Prime(num):\n            counter += 1\n    return counter\n\ndef is_Prime(num):\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n```"}
{"task_id": "MBPP/257", "completion": "\n\n```python\ndef swap_numbers(a, b):\n    a, b = b, a\n    return a, b\n```"}
{"task_id": "MBPP/259", "completion": "\n\n```python\ndef maximize_tuples(tuple1, tuple2):\n    maximized_list = []\n    for i in range(len(tuple1)):\n        if tuple1[i] > tuple2[i]:\n            maximized_list.append(tuple1[i])\n        else:\n            maximized_list.append(tuple2[i])\n    return tuple(maximized_list)\n```"}
{"task_id": "MBPP/260", "completion": "\n\n```python\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef nth_newman_shanks_williams_prime(n):\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if is_prime(num) and is_palindrome(num):\n            count += 1\n            if count == n:\n                return num\n    return None\n```\n\nThis function will return the `n`th Newman-Shanks-Williams prime number. If there is no such prime, it will return `None`. Note that this function is not very efficient, as it checks every integer to see if it's a prime and a palindrome. There are more efficient ways to generate primes and check if numbers are palindromes, but they're also more complex."}
{"task_id": "MBPP/261", "completion": "\n\n```python\ndef division_elements(test_tup1, test_tup2):\n    division_results = {}\n    for i in test_tup1:\n        for j in test_tup2:\n            division_results[(i, j)] = i / j\n    return division_results\n```"}
{"task_id": "MBPP/262", "completion": "\n\n```python\ndef split_list(lst, L):\n    if L > len(lst):\n        return \"Error: Length of the first part is greater than the length of the list.\"\n    else:\n        return (lst[:L], lst[L:])\n```\n\nThis function takes a list `lst` and an integer `L` as input. It returns a tuple containing two lists. The first list is the first part of the original list up to the given length `L`. The second list is the remaining part of the original list. If `L` is greater than the length of the list, it returns an error message."}
{"task_id": "MBPP/264", "completion": "\n\n```python\ndef dog_age(h_age):\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n```"}
{"task_id": "MBPP/265", "completion": "\n\n```python\ndef list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i+step])\n    return result\n```"}
{"task_id": "MBPP/266", "completion": "\n\n```python\ndef lateral_surface_area_of_cube(l):\n    return 4 * l ** 2\n```"}
{"task_id": "MBPP/267", "completion": "\n\n```python\ndef square_Sum(n):\n    sum = 0\n    count = 0\n    while True:\n        count += 1\n        if count % 2 != 0:\n            sum += count ** 2\n        if count % 2 == 1 and count % 2 == 0:\n            return sum\n        if count > 2 * n:\n            return sum\n```"}
{"task_id": "MBPP/268", "completion": "\n\n```python\ndef find_star_number(n):\n    count = 0\n    num = 1\n    while True:\n        digits = [int(i) for i in str(num)]\n        if sum(digits) == eval('*'.join(map(str, digits))):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    return None\n```\n\nThis function works by generating numbers and checking if they are star numbers. \nIt starts from 1 and increments by 1 in each iteration. \nFor each number, it converts it to a list of digits, then checks if the sum of the digits is equal to the product of the digits. \nIf it is, it increments the counter. \nIf the counter equals n, it returns the current number. \nIf it finishes the loop without finding the n'th star number, it returns `None`."}
{"task_id": "MBPP/269", "completion": "\n\n```python\ndef find_ascii_value(k):\n    return ord(k)\n```"}
{"task_id": "MBPP/270", "completion": "\n\n```python\ndef sum_even_numbers_at_even_positions(arr):\n    sum = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 == 0:\n            sum += arr[i]\n    return sum\n```"}
{"task_id": "MBPP/271", "completion": "\n\n```python\ndef sum_of_fifth_power_of_even_numbers(n):\n    return sum(i**5 for i in range(2, 2*n, 2))\n```"}
{"task_id": "MBPP/272", "completion": "\n\n```python\ndef extract_rear_elements(test_list):\n    rear_elements = [tup[-1] for tup in test_list]\n    return rear_elements\n```"}
{"task_id": "MBPP/273", "completion": "\n\n```python\ndef substract_elements(test_tup1, test_tup2):\n    result = ()\n    for i in range(len(test_tup1)):\n        result += (test_tup1[i] - test_tup2[i],)\n    return result\n```"}
{"task_id": "MBPP/274", "completion": "\n\n```python\nimport math\n\ndef even_binomial_Coeff_Sum(n):  \n    sum = 0  \n    for i in range(0, n + 1, 2):  \n        sum += math.comb(n, i)  \n    return sum  \nprint(even_binomial_Coeff_Sum(5))  \n```"}
{"task_id": "MBPP/276", "completion": "\n\n```python\nimport math\n\ndef calculate_cylinder_volume(r, h):\n    volume = math.pi * r**2 * h\n    return volume\n```"}
{"task_id": "MBPP/277", "completion": "\n\n```python\ndef filter_dict_by_value(input_dict, n):\n    filtered_dict = {}\n    for key, value in input_dict.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict\n```"}
{"task_id": "MBPP/278", "completion": "\n\n```python\ndef count_first_elements(test_tup):\n    element_count = {}\n    for element in test_tup:\n        if element not in element_count:\n            element_count[element] = 1\n        else:\n            element_count[element] += 1\n\n    max_count = max(element_count.values())\n    max_element = [k for k, v in element_count.items() if v == max_count][0]\n\n    return max_count, max_element\n```"}
{"task_id": "MBPP/279", "completion": "\n\n```python\ndef is_num_decagonal(n):\n    decagonal_num = n * (3 * n - 2) / 2\n    return decagonal_num.is_integer()\n```"}
{"task_id": "MBPP/280", "completion": "\n\n```python\ndef sequential_search(dlist, item):\n    index = 0\n    for element in dlist:\n        if element == item:\n            return index\n        index += 1\n    return -1\n```"}
{"task_id": "MBPP/281", "completion": "\n\n```python\ndef check_unique(test_list):\n    seen = set()\n    for element in test_list:\n        if element in seen:\n            return False\n        else:\n            seen.add(element)\n    return True\n```"}
{"task_id": "MBPP/282", "completion": "\n\n```python\ndef subtract_lists(nums1, nums2):\n    return list(map(lambda x, y: x - y, nums1, nums2))\n```"}
{"task_id": "MBPP/283", "completion": "\n\n```python\ndef check_digit_frequency(n):\n    freq_dict = {}\n    str_n = str(n)\n\n    for digit in str_n:\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        else:\n            freq_dict[digit] = 1\n\n    for key, value in freq_dict.items():\n        if value > int(key):\n            return False\n\n    return True\n```"}
{"task_id": "MBPP/284", "completion": "\n\n```python\ndef all_equal(list, element):\n    found_match = False\n    for item in list:\n        if item == element:\n            found_match = True\n            break\n    if found_match:\n        return True\n    else:\n        return False\n    return False\n```"}
{"task_id": "MBPP/285", "completion": "\n\n```python\nimport re\n\ndef match_pattern(text):\n    pattern = re.compile(r'ab{2,3}')\n    match = pattern.search(text)\n    if match:\n        return True\n    else:\n        return False\n```"}
{"task_id": "MBPP/286", "completion": "\n\n```python\ndef max_sub_array_sum_modified(a, n):\n    max_so_far = a[0]\n    curr_max = a[0]\n    for i in range(1, n):\n        curr_max = max(a[i], curr_max + a[i])\n        max_so_far = max(max_so_far, curr_max)\n    return max_so_far\n\ndef max_sum_k_times(a, k, n):\n    # Initialize result\n    max_sum = 0\n\n    # Calculate sum of original array\n    original_sum = sum(a)\n\n    # If sum of original array is 0, return k*original_sum\n    if original_sum == 0:\n        return k * original_sum\n\n    # Calculate max sum of subarray in original array\n    max_sub_array_sum = max_sub_array_sum_modified(a, n)\n\n    # Calculate result\n    max_sum = k * original_sum + (k - 1) * max_sub_array_sum\n\n    return max_sum\n```"}
{"task_id": "MBPP/287", "completion": "\n\n```python\ndef square_Sum(n):\n    return sum(i**2 for i in range(2, 2*n+2, 2))\n```"}
{"task_id": "MBPP/290", "completion": "\n\n```python\ndef find_max_length_lists(lst):\n    if not lst:\n        return []\n\n    max_length = 0\n    max_length_lists = []\n\n    for l in lst:\n        length = len(l)\n        if length > max_length:\n            max_length = length\n            max_length_lists = [l]\n        elif length == max_length:\n            max_length_lists.append(l)\n\n    return max_length_lists\n```"}
{"task_id": "MBPP/292", "completion": "\n\n```python\ndef find_quotient(n, m):\n    if m == 0:\n        return \"Error: Division by zero is undefined.\"\n    else:\n        return n / m\n```\n\nThis function takes two arguments, n and m, which represent the dividend and the divisor, respectively. It first checks if the divisor is 0. If it is, it returns an error message. If the divisor is not 0, it calculates the quotient by dividing the dividend by the divisor and returns the result."}
{"task_id": "MBPP/293", "completion": "\n\n```python\nimport math\n\ndef find_third_side(w, h):\n    c = math.sqrt(w**2 + h**2)\n    return c\n```"}
{"task_id": "MBPP/294", "completion": "\n\n```python\ndef max_val(listval):\n    max_val = None\n    for val in listval:\n        if isinstance(val, list):\n            max_val_sublist = max_val(val)\n            if max_val is None or (max_val_sublist is not None and max_val_sublist > max_val):\n                max_val = max_val_sublist\n        elif isinstance(val, (int, float)):\n            if max_val is None or val > max_val:\n                max_val = val\n    return max_val\n```"}
{"task_id": "MBPP/295", "completion": "\n\n```python\ndef sum_divisors(number):\n    sum_divisors = 0\n    for i in range(1, int(number**0.5) + 1):\n        if number % i == 0:\n            sum_divisors += i\n            if i != number // i:\n                sum_divisors += number // i\n    return sum_divisors\n```"}
{"task_id": "MBPP/296", "completion": "\n\n```python\ndef count_inversions(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n```\n\nThis function takes an array as input and returns the number of inversions in the array. The time complexity of this function is O(n^2) where n is the number of elements in the array. This is because we are using a nested loop to compare each element with all elements to its right. The space complexity is O(1) as we are using only a constant amount of space to store the count of inversions."}
{"task_id": "MBPP/297", "completion": "\n\n```python\ndef flatten_list(list1):\n    flattened_list = []\n    for element in list1:\n        if isinstance(element, list):\n            flattened_list.extend(flatten_list(element))\n        else:\n            flattened_list.append(element)\n    return flattened_list\n```"}
{"task_id": "MBPP/299", "completion": "\n\n```python\nfrom collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregate = defaultdict(int)\n    for tup in stdata:\n        if tup[0] in aggregate:\n            aggregate[tup[0]] += tup[1]\n        else:\n            aggregate[tup[0]] = tup[1]\n    return max(aggregate.values())\n```"}
{"task_id": "MBPP/300", "completion": "\n\n```python\ndef count_sequences(n):\n    memo = {}\n\n    def count(pos, sum):\n        if pos == n:\n            return 1 if sum == n else 0\n        if (pos, sum) in memo:\n            return memo[(pos, sum)]\n        memo[(pos, sum)] = count(pos + 1, sum + 1) + count(pos + 1, sum - 1)\n        return memo[(pos, sum)]\n\n    return count(0, 0)\n\nprint(count_sequences(1))  # Output: 2\nprint(count_sequences(2))  # Output: 8\nprint(count_sequences(3))  # Output: 24\n```\n\nThis code defines a function `count_sequences` that takes an integer `n` as input and returns the count of all binary sequences of length 2n such that the sum of the first n bits is the same as the sum of the last n bits. The function uses a helper function `count` and a dictionary `memo` for memoization. The helper function takes two parameters: the current position in the sequence and the current sum of the first half of the sequence. The function `count_sequences` returns the count for the initial position (current position is 0 and current sum is 0)."}
{"task_id": "MBPP/301", "completion": "\n\n```python\ndef nested_dict_depth(d):\n    depth = 0\n\n    def calculate_depth(current_dict, current_depth):\n        nonlocal depth\n        depth = max(depth, current_depth)\n        for value in current_dict.values():\n            if isinstance(value, dict):\n                calculate_depth(value, current_depth + 1)\n\n    calculate_depth(d, 1)\n    return depth\n```"}
{"task_id": "MBPP/305", "completion": "\n\n```python\ndef find_p_words(words):\n    p_words = [word for word in words if word.startswith('p') or word.startswith('P')]\n    return p_words[:2] if len(p_words) >= 2 else \"Less than two words start with 'p'.\"\n```"}
{"task_id": "MBPP/306", "completion": "\n\n```python\ndef max_sum_increasing_subseq(a, n, index, k):\n    max_sum_list = []\n\n    for i in range(n):\n        current_sum = 0\n\n        for j in range(i, index+1):\n            if j > 0 and a[j] > a[j-1]:\n                current_sum += a[j]\n\n            if j == index:\n                max_sum_list.append(current_sum)\n\n    return max(max_sum_list)\n```"}
{"task_id": "MBPP/308", "completion": "\n\n```python\ndef find_largest_products(nums1, nums2, N):\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    products.sort(reverse=True)\n    return products[:N]\n```"}
{"task_id": "MBPP/309", "completion": "\n\n```python\ndef max_of_two_numbers(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise ValueError(\"Both inputs must be numbers.\")\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return a\n```"}
{"task_id": "MBPP/310", "completion": "\n\n```python\ndef string_to_tuple(s):\n    return tuple(s)\n```"}
{"task_id": "MBPP/311", "completion": "\n\n```python\ndef set_left_most_unset_bit(n):\n    left_most_unset_bit = 1\n    for i in range(32):\n        if (n & (1 << i)) == 0:\n            left_most_unset_bit = 1 << i\n            break\n    return left_most_unset_bit\n```"}
{"task_id": "MBPP/312", "completion": "\n\n```python\nimport math\n\ndef volume_of_cone(r, h):\n    return (1/3) * math.pi * r**2 * h\n```"}
{"task_id": "MBPP/388", "completion": "\n\n```python\ndef highest_power_of_two(n):\n    highest_power = 1\n    i = 1\n    while True:\n        next_power = 2 ** i\n        if next_power > n:\n            break\n        highest_power = next_power\n        i += 1\n    return highest_power\n```"}
{"task_id": "MBPP/389", "completion": "\n\n```python\ndef nth_lucas(n):\n    if n < 0:\n        return \"Error: n must be a non-negative integer.\"\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a\n```"}
{"task_id": "MBPP/390", "completion": "\n\n```python\ndef insert_string_beginning(list, string):\n    return [string + item for item in list]\n```"}
{"task_id": "MBPP/391", "completion": "\n\n```python\ndef convert_list_dictionary(l1, l2, l3):\n    result = {}\n    for i in range(len(l1)):\n        if l1[i] not in result:\n            result[l1[i]] = l2[i]\n        else:\n            result[l1[i]] = {l2[i]: l3[i]}\n    return result\n```"}
{"task_id": "MBPP/392", "completion": "\n\n```python\ndef maxSum(n, dp={}):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n in dp:\n        return dp[n]\n    else:\n        dp[n] = max(n, maxSum(n//2, dp) + maxSum(n//3, dp) + maxSum(n//4, dp) + maxSum(n//5, dp))\n        return dp[n]\n```\n\nThis function takes an integer `n` as input and returns the maximum sum that can be obtained by recursively dividing `n` by 2, 3, 4, and 5 until it becomes 1 or less. The `dp` dictionary is used to store the results of each calculation to avoid redundant calculations."}
{"task_id": "MBPP/394", "completion": "\n\n```python\ndef check_distinct(test_tup):\n    seen = set()\n    for elem in test_tup:\n        if elem in seen:\n            return False\n        else:\n            seen.add(elem)\n    return True\n```"}
{"task_id": "MBPP/395", "completion": "\n\n```python\ndef first_non_repeated_char(str1):\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    return None\n```"}
{"task_id": "MBPP/396", "completion": "\n\n```python\nimport re\n\ndef check_char(string):\n    regex = r\"^[a-z]$|^([a-z]).*\\1$\"\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n```"}
{"task_id": "MBPP/397", "completion": "\n\n```python\ndef find_median(a, b, c):\n    # Arrange the numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Return the median (middle number)\n    return numbers[1]\n```\n\nThis function takes three numbers as input and returns the median of those numbers. The numbers are first sorted in ascending order using the sorted() function. Then, the middle number (numbers[1]) is returned as the median."}
{"task_id": "MBPP/398", "completion": "\n\n```python\ndef sum_digits(nums):\n    result = []\n    for num in nums:\n        str_num = str(num)\n        sum_digits = 0\n        for char in str_num:\n            if char.isdigit():\n                sum_digits += int(char)\n        result.append(sum_digits)\n    return result\n```"}
{"task_id": "MBPP/400", "completion": "\n\n```python\ndef extract_freq(test_list):\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n```"}
{"task_id": "MBPP/404", "completion": "\n\n```python\ndef min_of_two_numbers(num1, num2):\n    if num1 < num2:\n        return num1\n    else:\n        return num2\n```"}
{"task_id": "MBPP/405", "completion": "\n\n```python\ndef check_tuplex(tuplex, tuple1):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    # Iterate through each element in the tuple\n    for element in tuplex:\n        # If the element is in the given tuple, return True immediately\n        if element in tuple1:\n            return True\n\n    # If the loop finishes without finding a match, return False\n    return False\n```"}
{"task_id": "MBPP/406", "completion": "\n\n```python\ndef find_Parity(x):\n    parity = 0\n    while x:\n        parity ^= x & 1\n        x >>= 1\n    return parity\n```\n\nThis function works by iterating through each bit in the binary representation of the number. For each bit, if it's 1, we flip the parity. After the loop, we return the parity. The parity will be 0 if the number of 1s in the binary representation of the number is even, and 1 if it's odd."}
{"task_id": "MBPP/407", "completion": "\n\n```python\ndef next_bigger_number(n):\n    digits = list(str(n))\n    digits.sort(reverse=True)\n\n    first_incorrect = None\n    for i in range(len(digits) - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            first_incorrect = i\n            break\n\n    if first_incorrect is None:\n        return -1\n\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] > digits[first_incorrect]:\n            digits[i], digits[first_incorrect] = digits[first_incorrect], digits[i]\n            break\n\n    digits[first_incorrect:] = digits[first_incorrect:][::-1]\n    return int(''.join(digits))\n```"}
{"task_id": "MBPP/409", "completion": "\n\n```python\ndef min_product(list1):\n    min_product = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n```"}
{"task_id": "MBPP/410", "completion": "\n\n```python\ndef find_min(lst):\n    min_val = None\n    for val in lst:\n        if isinstance(val, (int, float)):\n            if min_val is None or val < min_val:\n                min_val = val\n    return min_val\n```"}
{"task_id": "MBPP/412", "completion": "\n\n```python\ndef remove_odd_numbers(l):\n    return [num for num in l if num % 2 == 0]\n```"}
{"task_id": "MBPP/413", "completion": "\n\n```python\ndef extract_nth_element(list1, n):\n    nth_elements = []\n    for tup in list1:\n        if len(tup) >= n:\n            nth_elements.append(tup[n-1])\n    return nth_elements\n```"}
{"task_id": "MBPP/414", "completion": "\n\n```python\ndef check_value_exists(sequence, value):\n    exists = False\n    for lst in sequence:\n        for element in lst:\n            if element == value:\n                exists = True\n                break\n        if exists:\n            break\n    return exists\n```\n\nThis function takes a sequence of lists and a value as input. It checks whether the value exists in any of the lists in the sequence. If it does, the function returns `True`. Otherwise, it returns `False`."}
{"task_id": "MBPP/415", "completion": "\n\n```python\ndef max_product_pair(nums):\n    if len(nums) < 2:\n        return None\n\n    max_product = float('-inf')\n    second_max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                second_max_product = max_product\n                max_product = product\n            elif product > second_max_product:\n                second_max_product = product\n\n    return (nums[i], nums[j]) if max_product > 0 else None\n```\n\nThis function works by iterating through each pair of elements in the array and calculating their product. If the product is greater than `max_product`, it updates `second_max_product` to be the previous `max_product` and updates `max_product` to be the new product. If the product is greater than `second_max_product` but not `max_product`, it updates `second_max_product` to be the new product. After iterating through all pairs, it returns the pair with the highest product. If `max_product` is negative, it returns `None`, as this means no valid pair was found."}
{"task_id": "MBPP/418", "completion": "\n\n```python\ndef max_length_sublist(lst):\n    max_length = 0\n    max_sublist = []\n\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n\n    return max_sublist or None\n```"}
{"task_id": "MBPP/419", "completion": "\n\n```python\ndef round_and_sum(list1):\n    rounded_numbers = [round(num) for num in list1]\n    sum_rounded_numbers = sum(rounded_numbers)\n    product = len(list1) * sum_rounded_numbers\n    return product\n\nlist1 = [1.2, 2.3, 3.4, 4.5]\nprint(round_and_sum(list1))\n```"}
{"task_id": "MBPP/420", "completion": "\n\n```python\ndef cube_sum(n):\n    cube_sum = 0\n    for i in range(2, 2 * n, 2):\n        cube_sum += i ** 3\n    return cube_sum\n```"}
{"task_id": "MBPP/421", "completion": "\n\n```python\ndef concat_tuple(test_tup, delimiter):\n    return delimiter.join(test_tup)\n```"}
{"task_id": "MBPP/422", "completion": "\n\n```python\ndef find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i**3\n    average = sum_of_cubes / n\n    return average\n```"}
{"task_id": "MBPP/424", "completion": "\n\n```python\ndef extract_rear(test_tuple):\n    return [string[-1] for string in test_tuple]\n\ntest_tuple = (\"hello\", \"world\", \"python\")\nprint(extract_rear(test_tuple))  # Output: ['o', 'd', 'n']\n```"}
{"task_id": "MBPP/425", "completion": "\n\n```python\ndef count_sublists(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/426", "completion": "\n\n```python\ndef filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))\n```"}
{"task_id": "MBPP/427", "completion": "\n\n```python\nimport re\n\ndef convert_date_format(dt):\n    pattern = re.compile(r'\\d{4}-\\d{2}-\\d{2}')\n    if not pattern.match(dt):\n        return \"Invalid date format. Please use yyyy-mm-dd.\"\n    year, month, day = map(int, dt.split('-'))\n    return '-'.join(map(str, [day, month, year]))\n```"}
{"task_id": "MBPP/428", "completion": "\n\n```python\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list\n```"}
{"task_id": "MBPP/429", "completion": "\n\n```python\ndef and_tuples(test_tup1, test_tup2):\n    result = [(i, j) for i in test_tup1 for j in test_tup2]\n    return tuple(result)\n```"}
{"task_id": "MBPP/430", "completion": "\n\n```python\ndef find_directrix(a, b, c):\n    return f\"y = x - {c/b}\"\n```\n\nThis function takes in the coefficients a, b, and c of the general form of a parabola, ax^2 + bx + c, and returns the equation of the directrix in the form \"y = x - k\", where k is a constant."}
{"task_id": "MBPP/431", "completion": "\n\n```python\ndef common_element(list1, list2):\n    set1 = set(list1)\n    for element in list2:\n        if element in set1:\n            return True\n    return False\n```"}
{"task_id": "MBPP/432", "completion": "\n\n```python\ndef find_median_trapezium(base1, base2, height):\n    \"\"\"\n    This function calculates the median of a trapezium.\n    :param base1: float, the length of the first base of the trapezium.\n    :param base2: float, the length of the second base of the trapezium.\n    :param height: float, the height of the trapezium.\n    :return: float, the median of the trapezium.\n    \"\"\"\n    return height\n```"}
{"task_id": "MBPP/433", "completion": "\n\n```python\ndef check_greater(number, arr):\n    for element in arr:\n        if not number > element:\n            return False\n    return True\n```"}
{"task_id": "MBPP/435", "completion": "\n\n```python\ndef last_digit(n):\n    return int(str(n)[-1])\n```\n\nThis function takes an integer `n` as input, converts it to a string, extracts the last character using the `[-1]` index, converts it back to an integer, and returns it."}
{"task_id": "MBPP/436", "completion": "\n\n```python\ndef neg_nos(list1):\n    neg_nums = [num for num in list1 if num < 0]\n    return neg_nums\n```"}
{"task_id": "MBPP/437", "completion": "\n\n```python\ndef remove_odd(str1):\n    result = \"\"\n    for char in str1:\n        if ord(char) % 2 == 0:\n            result += char\n    return result\n\nprint(remove_odd(\"abcdefg\"))\n```"}
{"task_id": "MBPP/438", "completion": "\n\n```python\ndef count_bidirectional_pairs(test_list):\n    tuple_pairs = {}\n    for tup in test_list:\n        if tup not in tuple_pairs:\n            tuple_pairs[tup] = 1\n        elif (tup[1], tup[0]) in tuple_pairs:\n            tuple_pairs[(tup[1], tup[0])] += 1\n        else:\n            tuple_pairs[tup] += 1\n    bidirectional_count = 0\n    for tup, count in tuple_pairs.items():\n        if count % 2 == 0:\n            bidirectional_count += 1\n    return bidirectional_count\n```"}
{"task_id": "MBPP/439", "completion": "\n\n```python\ndef multiple_to_single(L):\n    result = \"\"\n    for num in L:\n        result += str(num)\n    return int(result)\n```"}
{"task_id": "MBPP/440", "completion": "\n\n```python\ndef find_adverb_position(text):\n    adverbs_positions = {}\n    words = text.split(' ')\n    for i, word in enumerate(words):\n        if word.endswith('ly'):\n            adverbs_positions[word] = i\n    return adverbs_positions\n\nprint(find_adverb_position(\"She is quickly running.\"))\n```"}
{"task_id": "MBPP/441", "completion": "\n\n```python\ndef surface_area_of_cube(l):\n    return 6 * l ** 2\n```"}
{"task_id": "MBPP/442", "completion": "\n\n```python\ndef positive_ratio(nums):\n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n```"}
{"task_id": "MBPP/445", "completion": "\n\n```python\ndef index_multiplication(test_tup1, test_tup2):\n    result = ()\n    for i in range(len(test_tup1)):\n        result += (test_tup1[i] * test_tup2[i],)\n    return result\n```"}
{"task_id": "MBPP/446", "completion": "\n\n```python\nfrom collections import Counter\n\ndef count_elements(lst, tup):\n    count_obj = Counter(tup)\n    for i in lst:\n        if i in count_obj:\n            count_obj[i] += 1\n        else:\n            count_obj[i] = 1\n    return count_obj\n```"}
{"task_id": "MBPP/447", "completion": "\n\n```python\ndef cube_nums(nums):\n    return list(map(lambda x: x**3, nums))\n```"}
{"task_id": "MBPP/448", "completion": "\n\n```python\ndef sum_perrin(n):\n    if n < 0:\n        return \"Invalid input. Please enter a non-negative integer.\"\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        perrin_sum = 2\n        last_two = [0, 1]\n        for i in range(3, n+1):\n            current_perrin = last_two[0] + last_two[1]\n            perrin_sum += current_perrin\n            last_two[0] = last_two[1]\n            last_two[1] = current_perrin\n        return perrin_sum\n```"}
{"task_id": "MBPP/450", "completion": "\n\n```python\ndef extract_strings(string_list, size):\n    extracted_strings = [s for s in string_list if len(s) == size]\n    return extracted_strings\n```"}
{"task_id": "MBPP/451", "completion": "\n\n```python\nimport re\n\ndef remove_whitespaces(text):\n    return re.sub(r'\\s', '', text)\n```"}
{"task_id": "MBPP/453", "completion": "\n\n```python\nimport math\n\ndef sum_divisors(n):\n    sum = 0\n    for i in range(1, math.isqrt(n) + 1) : \n        if n % i == 0 : \n            if i % 2 == 0:\n                sum += i\n            if n // i != i and (n // i) % 2 == 0:\n                sum += n // i\n    return sum\n```"}
{"task_id": "MBPP/454", "completion": "\n\n```python\nimport re\n\ndef text_match_wordz(text):\n    words_with_z = re.findall(r'\\b\\w*z\\w*\\b', text)\n    return words_with_z\n```"}
{"task_id": "MBPP/455", "completion": "\n\n```python\ndef has_31_days(monthnum):\n    months_31_days = [1, 3, 5, 7, 8, 10, 12]\n    return monthnum in months_31_days\n```"}
{"task_id": "MBPP/456", "completion": "\n\n```python\ndef reverse_strings(stringlist):\n    return [string[::-1] for string in stringlist]\n```"}
{"task_id": "MBPP/457", "completion": "\n\n```python\ndef find_min_length_sublist(lst):\n    min_len = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n\n    if min_sublist is None:\n        return None\n    else:\n        return min_sublist\n```"}
{"task_id": "MBPP/458", "completion": "\n\n```python\ndef rectangle_area(l, b):\n    return l * b\n```"}
{"task_id": "MBPP/459", "completion": "\n\n```python\nimport re\n\ndef remove_uppercase_substrings(s):\n    return re.sub('[A-Z]+', '', s)\n```"}
{"task_id": "MBPP/460", "completion": "\n\n```python\ndef Extract(lst):\n    return [sublist[0] for sublist in lst]\n```"}
{"task_id": "MBPP/461", "completion": "\n\n```python\ndef upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n```"}
{"task_id": "MBPP/462", "completion": "\n\n```python\nimport itertools\n\ndef find_combinations(list1):\n    all_combinations = []\n    for r in range(1, len(list1) + 1):\n        for combination in itertools.combinations(list1, r):\n            all_combinations.append(combination)\n    return all_combinations\n```"}
{"task_id": "MBPP/463", "completion": "\n\nHere is the Python code for the above problem:\n\n```python\ndef max_product_subarray(nums):\n    if not nums:\n        return 0\n\n    max_ending_here = min_ending_here = max_so_far = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n```\n\nThis function takes an array of integers as input and returns the maximum product of a subarray. If the input array is empty, it returns 0."}
{"task_id": "MBPP/465", "completion": "\n\n```python\ndef drop_empty_items(dictionary):\n    non_empty_dict = {}\n    for key, value in dictionary.items():\n        if value not in [None, '', []]:\n            non_empty_dict[key] = value\n    return non_empty_dict\n```"}
{"task_id": "MBPP/468", "completion": "\n\nHere is the Python code for the above process:\n\n```python\ndef max_product_subsequence(nums):\n    max_ending_here = max_ending_prev = 1\n    max_product = 0\n\n    for num in nums:\n        if num > 1:\n            max_ending_here *= num\n            max_ending_prev = max(max_ending_prev, max_ending_here)\n        else:\n            max_ending_here = 1\n\n        max_product = max(max_product, max_ending_prev)\n\n    return max_product\n```\n\nThis function takes an array of integers as input and returns the maximum product of an increasing subsequence."}
{"task_id": "MBPP/470", "completion": "\n\n```python\ndef add_pairwise(test_tup):\n    result = []\n    for i in range(len(test_tup[0])):\n        result.append(test_tup[0][i] + test_tup[1][i])\n    return tuple(result)\n\nprint(add_pairwise((1, 2, 3), (4, 5, 6)))  # Output: (5, 7, 9)\n```"}
{"task_id": "MBPP/471", "completion": "\n\n```python\ndef find_remainder(arr, n):\n    product = 1\n    for i in range(len(arr)):\n        product *= arr[i]\n        if product >= n:\n            product %= n\n    return product\n```"}
{"task_id": "MBPP/472", "completion": "\n\n```python\ndef has_consecutive_numbers(l):\n    seen = set()\n    for num in l:\n        if num in seen:\n            return True\n        else:\n            seen.add(num)\n    return False\n```"}
{"task_id": "MBPP/473", "completion": "\n\n```python\ndef tuple_intersection(test_list1, test_list2):\n    set1 = set()\n    for tup in test_list1:\n        for elem in tup:\n            set1.add(elem)\n\n    intersect_list = []\n    for tup in test_list2:\n        for elem in tup:\n            if elem in set1:\n                intersect_list.append(elem)\n                set1.remove(elem)\n\n    # Step 6: After checking all tuples in the second list, return the intersecting elements list as a tuple.\n    return tuple(intersect_list)\n```"}
{"task_id": "MBPP/474", "completion": "\n\n```python\ndef replace_char(str1, ch, newch):\n    result = \"\"\n    for char in str1:\n        if char == ch:\n            result += newch\n        else:\n            result += char\n    return result\n```"}
{"task_id": "MBPP/475", "completion": "\n\n```python\nfrom collections import Counter\n\ndef sort_counter(dict1):\n    sorted_dict = Counter(sorted(dict1.items(), key=lambda item: item[1]))\n    return sorted_dict\n```"}
{"task_id": "MBPP/476", "completion": "\n\n```python\ndef sum_largest_smallest(arr):\n    min_val = float('inf')\n    max_val = float('-inf')\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val\n```"}
{"task_id": "MBPP/477", "completion": "\n\n```python\ndef to_lower_case(string):\n    return string.lower()\n```"}
{"task_id": "MBPP/478", "completion": "\n\n```python\nimport re\n\ndef remove_lowercase_substrings(str1):\n    result = \"\"\n    uppercase_substrings = re.findall(r'[A-Z]+', str1)\n    for substring in uppercase_substrings:\n        result += substring\n    return result\n```"}
{"task_id": "MBPP/479", "completion": "\n\n```python\ndef first_repeated_digit(n):\n    str_n = str(n)\n    seen_digits = set()\n    for char in str_n:\n        if char.isdigit():\n            if char in seen_digits:\n                return int(char)\n            else:\n                seen_digits.add(char)\n    return None\n```"}
