{"date": "2024-04-25 16:37", "hash": "ebe95df0d5220f00cedd6f4bddea35e4", "eval": {"Mbpp/3": [{"task_id": "Mbpp/3", "solution": "import math\n\ndef is_prime(n):\n    \"\"\"\n    Returns True if the given number is prime, otherwise False.\n    \n    >>> is_prime(2)\n    True\n    >>> is_prime(10)\n    False\n    >>> is_prime(35)\n    False\n    >>> is_prime(37)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def flip(arr, k):\n    \"\"\"\n    This function flips the first k elements in the list 'arr'.\n    \"\"\"\n    i = 0\n    while i < k / 2:\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n        i += 1\n\ndef find_max_index(arr, n):\n    \"\"\"\n    This function finds the index of the maximum element in the list 'arr' within the first 'n' elements.\n    \"\"\"\n    max_index = 0\n    for i in range(n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef pancake_sort(arr):\n    \"\"\"\n    This function sorts the input list 'arr' using the pancake sorting algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = find_max_index(arr, i + 1)\n        # Flip the sublist from the beginning to the index of the maximum element\n        flip(arr, max_index + 1)\n        # Flip the entire sublist from the beginning to the current position 'i'\n        flip(arr, i + 1)\n    return arr\n\n# Test the function with different input lists\ndef test_pancake_sort():\n    test_cases = [\n        [3, 1, 2, 4, 6, 5],\n        [10, 5, 8, 3, 2, 6, 4, 7, 9, 1],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1]\n    ]\n    for i, test_case in enumerate(test_cases):\n        sorted_arr = pancake_sort(test_case.copy())\n        print(f\"Test case {i + 1}: {sorted_arr}\")\n\ntest_pancake_sort()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares or not.\n    \n    Args:\n        n (int): The input number to check.\n    \n    Returns:\n        bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    \n    # Iterate through factors of n\n    for i in range(1, int(n ** 0.5) + 1):\n        \n        # If i is a factor of n\n        if n % i == 0:\n            \n            # Check if n - i^2 is a perfect square\n            if (n - i ** 2) >= 0 and ((n - i ** 2) ** 0.5).is_integer():\n                return True\n    \n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(input_string, replacement_char):\n        if not input_string:\n            return ''\n        return input_string.replace(' ', replacement_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(lst: List[int]) -> List[int]:\n    gap: int = len(lst)\n    swapped: bool = True\n    while gap > 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n        for i in range(len(lst) - gap):\n            j: int = i + gap\n            if lst[i] > lst[j]:\n                lst[i], lst[j] = lst[j], lst[i]\n                swapped = True\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)  # Get the length of the input string\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array to store lengths of longest palindromic subsequences\n    \n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1  # Set the diagonal elements to 1 since each single character is a palindrome of length 1\n    \n    # Build the dp table in a bottom-up manner\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i + cl - 1\n            # Check if the characters at both ends are the same and the length is 2\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            # Check if the characters at both ends are the same\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                # If the characters are different, take the maximum of the two options\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    \n    # The top-right corner of the dp table stores the length of the longest palindromic subsequence\n    return dp[0][n-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/229": [{"task_id": "Mbpp/229", "solution": "def re_arrange_array(arr, n):\n    if n >= len(arr) or n < 0:\n        raise ValueError(\"Invalid value of n\")\n        \n    i = 0\n    while i < n:\n        if arr[i] >= 0:\n            temp = arr[i]\n            for j in range(i + 1, n):\n                if arr[j] < 0:\n                    arr[i] = arr[j]\n                    arr[j] = temp\n                    temp = arr[i]\n        i += 1\n    return arr", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(lst1, lst2):\n    \"\"\"\n    Removes all elements from lst1 that are present in lst2\n    \"\"\"\n    if not lst2:\n        return lst1\n    new_list = [x for x in lst1 if x not in lst2]\n    return new_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def count_occurrences(numbers):\n    # handle edge cases\n    if len(numbers) < 2:\n        return {}\n\n    # initialize dictionary\n    counts = {}\n\n    # iterate over numbers and update counts\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n\n    return counts", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def find_maximum_subsequence_sum(arr):\n    if not arr:\n        return 0\n\n    n = len(arr)\n    inc_sum = [0] * n\n    dec_sum = [0] * n\n\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        dec_sum[i] = arr[i]\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc_sum[i] < inc_sum[j] + arr[i]:\n                inc_sum[i] = inc_sum[j] + arr[i]\n\n            if arr[i] < arr[j] and dec_sum[i] < dec_sum[j] + arr[i]:\n                dec_sum[i] = dec_sum[j] + arr[i]\n\n    max_sum = max([inc_sum[i] + dec_sum[i] - arr[i] for i in range(n)])\n\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_unique_elements(input_list):\n    \"\"\"\n    Extracts unique elements from a nested list and returns them as a set.\n\n    Args:\n    input_list: A nested list containing elements to extract unique values from.\n\n    Returns:\n    A set of unique elements extracted from the nested list.\n    \"\"\"\n    unique_elements = set()\n    for sublist in input_list:\n        if isinstance(sublist, list):\n            unique_elements.update(sublist)\n        else:\n            unique_elements.add(sublist)\n    \n    return unique_elements", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    Returns True if all the tuples have equal length, False otherwise.\n    \"\"\"\n    length = len(tuples[0])\n    for t in tuples[1:]:\n        if len(t) != length:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculates the volume of a sphere.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The volume of the sphere.\n    \"\"\"\n    volume = (4 / 3) * math.pi * radius**3\n    return round(volume, 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Divisible_by_11(n):\n    \"\"\"\n    >>> is_Divisible_by_11(12345)\n    False\n    >>> is_Divisible_by_11(1212112)\n    True\n    \"\"\"\n    return n % 11 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Args:\n    radius: The radius of the circle.\n    \n    Returns:\n    The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(main_list, sublist):\n    if not sublist:\n        return True \n    if not main_list:\n        return False \n    if sublist in main_list:\n        return True\n    if all(elem in main_list for elem in sublist):\n        return True\n    return False", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    Returns the closest smaller number than n.\n    If n is already the smallest number (0), 0 is returned.\n    \n    If the input is not a valid number, return an error message.\n\n    >>> closest_num(11)\n    10\n    >>> closest_num(7)\n    6\n    >>> closest_num(12)\n    11\n    >>> closest_num(0)\n    0\n    \"\"\"\n    if not isinstance(n, (int, float)):\n        return \"Error: Input must be a number.\"\n    if n == 0:\n        return 0\n    return n - 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    if len(arr) <= 1:\n        return True\n    \n    increasing = True\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            increasing = False\n            break\n    \n    if increasing:\n        return True\n    \n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "from collections import defaultdict\n\ndef freq_count(lst):\n    counts = defaultdict(int)\n    unique_elems = set(lst)\n    \n    for elem in unique_elems:\n        counts[elem] = lst.count(elem)\n    \n    return dict(counts)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "function nextPerfectSquare(num) {\n    if (num < 0) {\n        return \"Input must be a positive number.\";\n    }\n\n    let sqrt = Math.ceil(Math.sqrt(num));\n\n    while (true) {\n        if (Number.isInteger(Math.sqrt(sqrt * sqrt))) {\n            return sqrt * sqrt;\n        }\n        sqrt++;\n    }\n}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    return min(a, b, c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "from math import comb\n\ndef bell_number(n, memo={}):\n    if n == 0:\n        return 1\n    if n in memo:\n        return memo[n]\n\n    result = 0\n    for k in range(n):\n        result += comb(n, k) * bell_number(k, memo)\n    \n    memo[n] = result\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def remove_odd_index_characters(input_string):\n    # Check if input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Use list comprehension to remove characters at odd indices\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(first_list, second_list):\n    first_list[-1:] = second_list\n    return first_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    binary_str = bin(n)[2:]\n    return binary_str.count('1')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    # Keep dividing n by 2 until it's no longer greater than 1\n    while n > 1:\n        # If n is not divisible by 2 (i.e., odd), it can't be expressed as a sum of powers of 2\n        if n % 2 != 0:\n            return False\n        n = n // 2  # Divide n by 2\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-14]]}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(d1, d2, d3):\n    merged = {}\n    merged.update(d1)\n    merged.update(d2)\n    merged.update(d3)\n    return merged", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns(input_list, patterns):\n    \"\"\"\n    Check whether the input list follows the sequence given in the patterns array.\n\n    Args:\n    input_list (list): List of strings to be checked.\n    patterns (list): List of strings specifying the expected pattern.\n\n    Returns:\n    bool: True if the input list follows the pattern, False otherwise.\n    \"\"\"\n    if len(input_list) != len(patterns):  # Handling different lengths of input list and patterns array\n        return False\n    \n    pattern_dict = {}\n    used_patterns = set()  # To keep track of used patterns\n\n    for i in range(len(input_list)):\n        if input_list[i] not in pattern_dict:  # If input string is not in pattern dictionary\n            if patterns[i] in used_patterns:  # If the pattern is already used\n                return False\n            pattern_dict[input_list[i]] = patterns[i]  # Add input string and its pattern to dictionary\n            used_patterns.add(patterns[i])  # Add pattern to set of used patterns\n        else:\n            if pattern_dict[input_list[i]] != patterns[i]:  # If input string is in pattern dictionary but the pattern is not same\n                return False\n\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["red", "red", "red", "red", "red", "red"], ["a", "b", "c", "a", "b", "c"]]]}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    # Check if the array is not empty\n    if len(arr) == 0:\n        return None\n    \n    result = 0\n    # Loop through the array\n    for num in arr:\n        # Bitwise XOR operation to find the non-repeating element\n        result += num\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def extended_gcd(a, b):\n    \"\"\"\n    Compute the extended Euclidean algorithm.\n\n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n\n    Returns:\n    tuple: A tuple (g, x, y) where g is the greatest common divisor of a and b, and x, y are integers such that\n    ax + by = g.\n    \"\"\"\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        gcd, x, y = extended_gcd(b, a % b)\n        return (gcd, y, x - (a // b) * y)\n\ndef find_solution(a, b, n):\n    \"\"\"\n    Find a solution to the linear congruence equation ax \u2261 b (mod n).\n\n    Parameters:\n    a (int): Coefficient of the unknown x.\n    b (int): Constant term.\n    n (int): Modulus.\n\n    Returns:\n    tuple: A tuple (x, y) where x is a particular solution to the congruence equation, and y is an integer.\n    \"\"\"\n    gcd, x, y = extended_gcd(a, b)\n    if gcd == 0:\n        return None\n    else:\n        if n % gcd != 0:\n            return None\n        else:\n            x *= n // gcd\n            y *= n // gcd\n            return (x, y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[25, 10, 500]]}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(numbers: List[int]) -> int:\n    return sum(1 for num in numbers if num > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Returns the nth centered hexagonal number, calculated using the formula 3n^2 - 3n + 1.\n\n    :param n: A positive integer representing the position of the centered hexagonal number in the sequence.\n    :return: The nth centered hexagonal number.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return 3 * n**2 - 3 * n + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "from typing import List, Union\n\ndef recursive_list_sum(lst: List[Union[int, List]]) -> int:\n    if not isinstance(lst, list):\n        return lst\n    flattened = [recursive_list_sum(element) for element in lst]\n    return sum(flattened)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "def zero_ratio(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n    arr: list of integers\n\n    Returns:\n    float: ratio of zeroes to non-zeroes, or 0.0 if the array is empty\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return 0.0\n    \n    return zero_count / non_zero_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculates the surface area of a sphere.\n    \n    Args:\n    radius: The radius of the sphere.\n    \n    Returns:\n    The surface area of the sphere.\n    \"\"\"\n    return 4 * math.pi * radius**2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the total number of sequences of length n,\n    where each element is a positive integer and is\n    greater than or equal to twice the previous element\n    but less than or equal to m.\n    \n    Args:\n    m (int): The upper limit for elements in the sequence.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    # Input validation to ensure that m and n are positive integers\n    if not isinstance(m, int) or not isinstance(n, int) or m <= 0 or n <= 0:\n        raise ValueError(\"m and n must be positive integers.\")\n    \n    # Base case: if n is 1, each integer from 1 to m is a valid sequence.\n    if n == 1:\n        return m\n    \n    total_sequences = 0\n    \n    # Iterate through each possible value for the first element of the sequence.\n    for first_element in range(1, m+1):\n        # Calculate the upper limit for the next element based on the first element.\n        upper_limit = min(first_element * 2 - 1, m)\n        # Recursively calculate the number of sequences for n-1 elements starting from the next element.\n        total_sequences += get_total_number_of_sequences(upper_limit, n-1)\n    \n    return total_sequences", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def series_sum(n):\n    total_sum = 0\n    for i in range(n):\n        if n - 2*i <= 0:\n            break\n        total_sum += n - 2*i\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_longest_word(word_list):\n    max_length = 0\n    longest_word = \"\"\n    for word in word_list:\n        if len(word) > max_length:\n            max_length = len(word)\n            longest_word = word\n    return (max_length, longest_word)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    \"\"\"\n    Function to count the number of non-empty substrings of a given string.\n\n    Args:\n        s (str): Input string\n\n    Returns:\n        int: Number of non-empty substrings\n    \"\"\"\n    n = len(s)\n    # The formula n*(n+1)//2 calculates the number of non-empty substrings using the sum of the first n natural numbers\n    return n*(n+1)//2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "Certainly! Could you please provide the original code you want me to modify?", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurrence(s):\n    # Initialize counter\n    count = 0\n\n    # Iterate through the string\n    for i in range(len(s) - 2):\n        # Check if the substring from current position to next two characters matches 'std'\n        if s[i:i+3] == 'std':\n            # If it matches, increment the counter\n            count += 1\n\n    # Return the count\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/117": [{"task_id": "Mbpp/117", "solution": "def convert_to_float(lst):\n    result = [\n        tuple(float(element) if not isinstance(element, float) else element for element in sublist)\n        for sublist in lst\n    ]\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(num1, num2):\n    result = num1 * num2\n    return result\n\n# Test cases using assert statement\nassert multiply_int(2, 3) == 6\nassert multiply_int(-1, 5) == -5\nassert multiply_int(0, 10) == 0\nassert multiply_int(11, 0) == 0\n\n# Additional edge cases\nassert multiply_int(-10, -10) == 100\nassert multiply_int(1, 1) == 1\nassert multiply_int(999999, 1) == 999999", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "from typing import Dict\n\ndef sequence(n: int) -> int:\n    \"\"\"\n    Returns the nth number in the Newman Conway sequence.\n    \n    The Newman Conway sequence is defined as follows:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n - P(n-1)) for n > 2\n    \n    Args:\n        n (int): The position of the number in the sequence to be returned.\n    \n    Returns:\n        int: The nth number in the Newman Conway sequence.\n    \n    Raises:\n        ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    memo: Dict[int, int] = {}\n    \n    def helper(n: int) -> int:\n        if n == 1 or n == 2:\n            return 1\n        if n in memo:\n            return memo[n]\n        \n        memo[n] = helper(helper(n-1)) + helper(n - helper(n-1))\n        return memo[n]\n    \n    return helper(n)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def sort_tuples_by_second_value(tuples):\n    return sorted(tuples, key=lambda x: x[1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference(lst):\n    max_diff = 0\n    for pair in lst:\n        a, b = pair\n        diff = abs(a - b)\n        max_diff = max(max_diff, diff)\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    if not lst or not all(isinstance(x, tuple) and len(x) == 2 for x in lst):\n        return None  # Handle input validation cases\n    \n    max_product = float('-inf')  # Initialize max_product to negative infinity\n    for pair in lst:\n        product = abs(pair[0] * pair[1])  # Calculate the absolute product of the pair\n        if product > max_product:  # Update max_product if the current product is greater\n            max_product = product\n    return max_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(lst, num): \n    freq_dict = {} \n    for element in lst: \n        freq_dict[element] = freq_dict.get(element, 0) + 1 \n    return freq_dict.get(num, 0)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[23.020319535944452, [5, false, -74, -50, -9, 5, 4, -97], "", [], false, 2, "VjPVjygOQshwex", "VjPVjygOQshwVjPshwexex", "q"], 2]]}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a given list.\n\n    Parameters:\n    lst (list): The list of numbers.\n\n    Returns:\n    int: The smallest number in the list. Raises ValueError if list is empty.\n    \"\"\"\n    if not lst:  # check if the list is empty\n        raise ValueError(\"List cannot be empty\")\n    return min(lst)  # find the smallest number using the min() function", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "from collections import Counter\n\ndef check_occurences(lst):\n    return dict(Counter(lst))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(t):\n    result = int(''.join(map(str, t)))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_substrings_with_sum_equals_length(string):\n    def has_sum_equals_length(substring):\n        digits = list(map(int, substring))\n        digit_sum = sum(digits)\n        return digit_sum == len(substring)\n\n    count = 0\n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            if has_sum_equals_length(string[i:j]):\n                count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    # Create a mask with all even bits set to 1\n    mask = 0b10101010101010101010101010101010\n    # Perform a bitwise OR operation to set even bits\n    return num | mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/115": [{"task_id": "Mbpp/115", "solution": "def empty_dict(lst):\n    \"\"\"\n    Returns True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    empty_count = 0  # Counter to keep track of the number of empty dictionaries\n    total_dicts = len(lst)  # Total number of dictionaries in the list\n    \n    for dictionary in lst:\n        if len(dictionary) == 0:\n            empty_count += 1\n            \n    return empty_count == total_dicts", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/83": [{"task_id": "Mbpp/83", "solution": "There is no given code to modify. Could you please provide the code that needs to be modified according to the teacher's requirements?", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length: float) -> float:\n    \"\"\"\n    Calculates the volume of a cube given its side length.\n\n    Args:\n        side_length (float): The length of one side of the cube.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return side_length ** 3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Returns the nth tetrahedral number.\n\n    A tetrahedral number is the sum of the first n triangular numbers.\n    A triangular number is the sum of all positive integers up to a given number.\n\n    Args:\n        n (int): The position of the tetrahedral number to be calculated.\n\n    Returns:\n        int: The nth tetrahedral number.\n    \"\"\"\n    if n == 0:\n        return 0\n    return (n * (n + 1) * (n + 2)) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return abs(max_val - min_val)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateralsuface_cylinder(height, radius):\n    \"\"\"\n    Calculates the lateral surface area of a cylinder.\n    \n    Parameters:\n    height (float): The height of the cylinder.\n    radius (float): The radius of the base of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    circumference = 2 * math.pi * radius\n    lateral_area = height * circumference\n    return lateral_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    return a * b < 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/143": [{"task_id": "Mbpp/143", "solution": "from typing import Tuple\n\ndef find_lists(tuple_input: Tuple) -> int:\n    \"\"\"\n    Returns the number of lists present in the given tuple.\n    \"\"\"\n    return sum(1 for item in tuple_input if isinstance(item, list))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def is_word_length_odd(word):\n    if len(word) % 2 != 0:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    if len(nested_lists) == 0:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements & set(lst)\n    \n    return sorted(common_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[9, 8, 7, 6, 5], [5, 6, 7, 8, 9], [9, 8, 7, 6, 5], [6, 7, 8, 9]]]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(lst, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    lst: List of tuples\n    k: Divisor\n\n    Returns:\n    List of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Returns the perimeter of a regular pentagon given the length of its sides.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 5 * side_length", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_identical_items_in_same_position(list1, list2, list3):\n    \"\"\"\n    This function counts the number of identical items in the same position of three given lists.\n\n    Args:\n    list1: The first input list.\n    list2: The second input list.\n    list3: The third input list.\n\n    Returns:\n    The count of identical items in the same position of the input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return \"Input lists have different lengths\"\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list2[i] == list3[i]:\n            count += 1\n\n    return count\n\n# Test cases\nprint(count_identical_items_in_same_position([1, 2, 3], [1, 2, 3], [1, 4, 3]))  # Should return 2\nprint(count_identical_items_in_same_position([5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]))  # Should return 4\nprint(count_identical_items_in_same_position([1, 2, 3], [4, 5, 6], [7, 8, 9]))  # Should return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(bin_str, num_rotations):\n    nums = [int(i) for i in bin_str]\n    count_odd = 0\n    for num in nums:\n        if num % 2 == 1:\n            count_odd += 1\n    rotated_nums = nums[num_rotations:] + nums[:num_rotations]\n    for num in rotated_nums:\n        if num % 2 == 1:\n            count_odd += 1\n    return count_odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position in the string as in the English alphabet.\n    \n    The function is case insensitive, as it converts the string to lowercase.\n    It counts only alphabetic characters that match their position in the English alphabet.\n    \n    Args:\n    string: input string\n    \n    Returns:\n    count: number of characters that occur at the same position in the string as in the English alphabet\n    \"\"\"\n    \n    count = 0\n    string = string.lower()  # Convert string to lowercase for case insensitivity\n    \n    for i, char in enumerate(string):\n        # Check if the character is an alphabet letter and its position matches its position in the English alphabet\n        if char.isalpha() and ord(char) - ord('a') == i:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    return 2*n**2 - n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(n):\n    \"\"\"\n    Check if a number is undulating.\n\n    Args:\n    - n: an integer\n\n    Returns:\n    - True if the number is undulating (alternating between increasing and decreasing digits), False otherwise\n\n    Examples:\n        >>> is_undulating(1212121)\n        True\n        >>> is_undulating(1991)\n        False\n        >>> is_undulating(121)\n        True\n    \"\"\"\n\n    digits = str(n)\n    \n    if len(digits) < 3:\n        return False\n    \n    for i in range(2, len(digits)):\n        if digits[i] == digits[i-1] or digits[i-1] == digits[i-2]:\n            return False\n        elif digits[i] > digits[i-1] and digits[i-1] > digits[i-2]:\n            return False\n        elif digits[i] < digits[i-1] and digits[i-1] < digits[i-2]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2121212121212120]]}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(number):\n    # Reverse the number by converting it to a string, reversing it, and converting it back to an integer\n    reverse = int(str(number)[::-1])\n    \n    # Calculate the target value by multiplying the reverse by 2 and subtracting 1\n    target = 2 * reverse - 1\n    \n    # Check if the given number is equal to the target value\n    return number == target", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    combined_list = list1 + list2 + list3\n    return sorted(combined_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    num_set = set()\n    for num in arr:\n        if num in num_set:\n            return True\n        num_set.add(num)\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(first_string, second_string):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n    first_string: The string from which characters are to be removed.\n    second_string: The string containing characters that need to be removed.\n\n    Returns:\n    The first string after removing characters present in the second string.\n    \"\"\"\n    if first_string is None or second_string is None:\n        return None\n    \n    if first_string == '' or second_string == '':\n        return first_string\n    \n    second_set = set(second_string)\n    new_string = ''\n    \n    for char in first_string:\n        if char not in second_set:\n            new_string += char\n            \n    return new_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "from typing import List, Tuple, Optional\n\ndef index_minimum(lst: List[Tuple[str, int]]) -> Optional[str]:\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the given list of tuples.\n    \"\"\"\n    if not lst:\n        return None\n    \n    min_second_val = float('inf')\n    min_val = None\n    \n    for first, second in lst:\n        if second < min_second_val:\n            min_second_val = second\n            min_val = first\n    \n    return min_val", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["Adam", 150, "NYC", true], ["Benjamin", 100, "LA", false], ["Charlie", 200, "Chicago", true], ["David", 125, "Miami", false]]]]}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    result = tpl + tuple(lst)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    if b == 0:\n        return 1\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_largest_number(digits):\n    \"\"\"\n    Returns the largest number that can be formed with the given list of digits.\n    \n    Args:\n    digits - A list of integers representing the digits\n    \n    Returns:\n    The largest number that can be formed with the digits\n    \"\"\"\n    digits = sorted(digits, reverse=True)\n    if 0 in digits:\n        zero_index = digits.index(0)\n        digits = [str(digits[zero_index])] + [str(d) for d in digits[:zero_index]] + [str(d) for d in digits[zero_index+1:]]\n    else:\n        digits = [str(d) for d in digits]\n    return int(''.join(digits))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(lst):\n    min_length = float('inf')\n    for sub_lst in lst:\n        length = len(sub_lst)\n        if length < min_length:\n            min_length = length\n    return min_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(num):\n    \"\"\"\n    Checks if the given number is a Woodall number.\n    \n    Parameters:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if the number is a Woodall number, False otherwise\n    \"\"\"\n    woodall_num = num * 2**num + 1\n    return woodall_num == num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def is_substring_present(string_list, substring):\n    if not isinstance(string_list, list):\n        raise TypeError('String list must be a list')\n    if not isinstance(substring, str):\n        raise TypeError('Substring must be a string')\n\n    # Convert substring and list elements to lowercase for case insensitivity\n    substring = substring.lower()\n    string_list = [string.lower() for string in string_list]\n\n    # Use a set for efficient lookup\n    string_set = set(string_list)\n\n    return substring in string_set", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(length):\n    return length * 4", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Args:\n    lst : list of int : input list of numbers\n    start : int : starting index of the range\n    end : int : ending index of the range\n\n    Returns:\n    int : sum of numbers in the specified range of indices\n    \"\"\"\n    if start > end:\n        start, end = end, start  # Swap start and end indices if start is greater than end\n    total_sum = 0\n    for i in range(max(0, start), min(end + 1, len(lst))):  # Validate indices to ensure they are within bounds\n        total_sum += lst[i]\n    return total_sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 7, 5]]}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "import re\n\ndef text_lowercase_underscore(input_str):\n    # Handle edge cases\n    if not input_str or input_str.count('_') == len(input_str):\n        return False\n\n    # Use regular expression to check for lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n    match = re.search(pattern, input_str)\n\n    return match is not None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Aaab_abbbc"]], "plus_fail_tests": [["abc_def_ghi_"]]}], "Mbpp/164": [{"task_id": "Mbpp/164", "solution": "def are_sum_of_divisors_equal(num1, num2):\n    \"\"\"\n    Determines if the sum of divisors of two integers are the same.\n    \n    Args:\n    num1 (int): First integer.\n    num2 (int): Second integer.\n    \n    Returns:\n    bool: True if the sum of divisors for both integers are equal, False otherwise.\n    \"\"\"\n    def calculate_sum_of_divisors(n):\n        \"\"\"\n        Calculates the sum of divisors for a given integer.\n        \n        Args:\n        n (int): The integer for which to calculate the sum of divisors.\n        \n        Returns:\n        int: The sum of divisors for the given integer.\n        \"\"\"\n        divisors_sum = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    return calculate_sum_of_divisors(num1) == calculate_sum_of_divisors(num2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import cmath\n\ndef angle_complex(real, imag):\n    \"\"\"\n    Get the angle of a complex number in radians\n    \n    Args:\n    real: The real part of the complex number\n    imag: The imaginary part of the complex number\n    \n    Returns:\n    The angle of the complex number in radians\n    \"\"\"\n    if real == 0 and imag == 0:\n        raise ValueError(\"Invalid input: Both real and imaginary parts are zero\")\n    \n    return cmath.phase(complex(real, imag))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count(bool_list):\n    return bool_list.count(True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume(length1, length2, height):\n    \"\"\"\n    Calculates the volume of a triangular prism.\n\n    Parameters:\n    length1 (float): length of the first side of the base triangle\n    length2 (float): length of the second side of the base triangle\n    height (float): height of the triangular prism\n\n    Returns:\n    float: the volume of the triangular prism\n    \"\"\"\n    base_area = (length1 * length2) / 2\n    volume = base_area * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    for sublist in lst:\n        sublist.sort()\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum(num1, num2):\n    \"\"\"\n    This function calculates the sum of common divisors of two given numbers.\n    \n    Args:\n    num1: First number\n    num2: Second number\n    \n    Returns:\n    Sum of common divisors of num1 and num2\n    \"\"\"\n    \n    def find_divisors(n):\n        divisors = [1]\n        for i in range(2, n):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    divisors1 = find_divisors(num1)\n    divisors2 = find_divisors(num2)\n    \n    common_divisors = set(divisors1).intersection(set(divisors2))\n    \n    divisor_sum = sum(common_divisors)\n    \n    return divisor_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=lambda x: sum(x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Returns the nth hexagonal number.\n\n    Parameters:\n    - n (int): The position of the hexagonal number to find.\n\n    Returns:\n    - int: The nth hexagonal number.\n\n    Examples:\n    >>> hexagonal_num(10)\n    190\n    >>> hexagonal_num(5)\n    45\n    >>> hexagonal_num(7)\n    91\n    \"\"\"\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m == 0:\n        return 1\n    else:\n        return (m+1) * eulerian_num(n-1, m) + (n-m) * eulerian_num(n-1, m-1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    \n    if first_index != -1 and last_index != -1:\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n    elif first_index != -1:\n        return string[:first_index] + string[first_index+1:]\n    elif last_index != -1:\n        return string[:last_index] + string[last_index+1:]\n    else:\n        return string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations(string):\n    rotations = 1\n    while True:\n        rotated_string = string[-1] + string[:-1]  # Perform a rotation\n        if rotated_string == string:  # Check if the rotated string is the same as the original string\n            return rotations\n        rotations += 1\n        if rotations > len(string):  # If we have performed more rotations than the length of the string, it is not possible to get the same string\n            return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ab"]], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, words):\n    if not isinstance(n, int) or n <= 0:\n        return \"Error: n must be a positive integer.\"\n    \n    if isinstance(words, str):\n        word_list = words.split()\n    elif isinstance(words, list):\n        word_list = words\n    else:\n        return \"Error: words must be a string or a list of strings.\"\n    \n    result = [word for word in word_list if isinstance(word, str) and len(word) > n]\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def calculate_sum_of_negative_numbers(numbers):\n    \"\"\"\n    This function calculates the sum of negative numbers in a given list.\n\n    Parameters:\n    numbers (list): A list of numbers to iterate through.\n\n    Returns:\n    int: The sum of negative numbers.\n    \"\"\"\n    # Initialize the running total\n    negative_sum = 0\n    \n    # Iterate through the list of numbers\n    for num in numbers:\n        # Check if the number is negative\n        if num < 0:\n            # If negative, add it to the running total\n            negative_sum += num\n    \n    # Return the sum of negative numbers\n    return negative_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(string):\r\n    if not string:  # Validate input\r\n        return \"\"\r\n\r\n    fragments = string.split('_')\r\n    camel_case_words = [fragments[0]] + [word.capitalize() for word in fragments[1:]]\r\n    return ''.join(camel_case_words)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "Sorry, but I'm unable to generate the modified code for you.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(num):\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    words = string.split()\n    valid_words = []\n    for word in words:\n        if len(word) >= 4:\n            valid_words.append(word)\n    return valid_words", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if the given matrix is a magic square.\n    :param matrix: 2D list representing the matrix\n    :return: True if it's a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n\n    # Return False for an empty matrix\n    if n == 0:\n        return False\n\n    # Return False if the matrix has different row and column numbers\n    if n != len(matrix[0]):\n        return False\n\n    # Calculate the magic number (the expected sum of each row, column, or diagonal)\n    magic_number = n * (n ** 2 + 1) // 2\n\n    # Check the sum of each row, column, the main and secondary diagonals\n    for i in range(n):\n        row_sum = col_sum = diag_sum = sec_diag_sum = 0\n        for j in range(n):\n            row_sum += matrix[i][j]\n            col_sum += matrix[j][i]\n            if i == j:\n                diag_sum += matrix[i][j]\n            if i + j == n - 1:\n                sec_diag_sum += matrix[i][j]\n        if row_sum != magic_number or col_sum != magic_number:\n            return False\n    if diag_sum != magic_number or sec_diag_sum != magic_number:\n        return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[7, 7], [7, 7]]]]}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def find_max_freq_item(lst):\n    if len(lst) == 0:\n        return None\n\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    max_freq_item = None\n    max_freq = 0\n    for key, value in freq_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_freq_item = key\n\n    return max_freq_item", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(s):\n    max_diff = 0\n    zeros = 0\n    ones = 0\n\n    for char in s:\n        if char == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n        curr_diff = zeros - ones\n        max_diff = max(max_diff, curr_diff)\n\n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["100000011100000000111111111000000011111101"]]}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integers(arr):\n    if not arr:\n        return 0\n    else:\n        return len([x for x in arr if isinstance(x, int)])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    if n <= 0:\n        return 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    return n + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def sum_of_proper_divisors(num):\n    # Finds the sum of proper divisors of a number\n    divisor_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\n\ndef amicable_numbers_sum(limit):\n    # Finds the sum of amicable numbers up to a given limit\n    amicable_sum = 0\n    visited = set()\n    for a in range(1, limit + 1):\n        if a not in visited:\n            b = sum_of_proper_divisors(a)\n            if b != a and sum_of_proper_divisors(b) == a:\n                visited.add(a)\n                visited.add(b)\n                amicable_sum += a + b\n    return amicable_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal //= 2\n    return binary", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "def calculate_average_product(numbers):\n    if not numbers:\n        return 0.0\n    result = 1\n    for num in numbers:\n        result *= num\n    result //= len(numbers)\n    return float(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(a, b):\n    bin_a = bin(a)[2:]\n    bin_b = bin(b)[2:]\n    if len(bin_a) != len(bin_b):\n        if len(bin_a) > len(bin_b):\n            bin_b = bin_b.zfill(len(bin_a))\n        else:\n            bin_a = bin_a.zfill(len(bin_b))\n    diff_count = 0\n    for bit_a, bit_b in zip(bin_a, bin_b):\n        if bit_a != bit_b:\n            diff_count += 1\n    return diff_count == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, 10]]}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return set1 & set2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "def convert(complex_num):\n    real_part = complex_num.real\n    imaginary_part = complex_num.imag\n    if imaginary_part == 0:\n        return str(real_part)\n    elif real_part == 0:\n        return str(imaginary_part) + \"i\"\n    elif imaginary_part < 0:\n        return str(real_part) + \" - \" + str(abs(imaginary_part)) + \"i\"\n    else:\n        return str(real_part) + \" + \" + str(imaginary_part) + \"i\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\nfrom typing import List\n\ndef heap_queue_largest(numbers: List[int], num_largest: int) -> List[int]:\n    \"\"\"\n    Returns the n largest integers from the given list of numbers, in descending order.\n    \"\"\"\n    if len(numbers) == 0 or num_largest <= 0:\n        return []\n    \n    if num_largest >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    return heapq.nlargest(num_largest, numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_indices = [i for i, char in enumerate(s) if char in vowels]\n    reversed_string = ''.join([s[vowel_indices.pop()] if char in vowels else char for char in s])\n    return reversed_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(lst):\n    flattened_list = [item for sublist in lst for item in sublist]\n    frequency_dict = {}\n    for element in flattened_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup: tuple) -> str:\n    return ''.join(map(str, tup))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element_before_each(lst, element):\n    return [element, x for x in lst]\n\n# Test cases\nprint(insert_element_before_each([1, 2, 3], 0))  # Output: [0, 1, 0, 2, 0, 3]\nprint(insert_element_before_each(['a', 'b', 'c'], 'z'))  # Output: ['z', 'a', 'z', 'b', 'z', 'c']", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tuple_data, x):\n    return tuple_data.count(x)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, target):\n    \"\"\"\n    Returns True if the given element is the majority element in the sorted array.\n    \n    Args:\n    arr (list): The sorted input array.\n    n (int): The length of the array.\n    target (int): The element to check for majority.\n    \n    Returns:\n    bool: True if the element is the majority element, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n    \n    # Binary search for the first occurrence of target\n    left = 0\n    right = n - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # Check if target is the majority element\n    if arr[left] != target:\n        return False\n    \n    # Check if target occurs more than n/2 times\n    count = 0\n    for i in range(left, n):\n        if arr[i] == target:\n            count += 1\n        else:\n            break\n    return count > n / 2", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(input_tuple):\n    \"\"\"\n    Check if all elements in the tuple have the same data type\n    \n    Args:\n    input_tuple: tuple\n    \n    Returns:\n    True if all elements have the same data type, False otherwise\n    \"\"\"\n    if not input_tuple: # Empty tuple\n        return True\n    \n    data_type = type(input_tuple[0])\n    for element in input_tuple:\n        if type(element) != data_type:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/249": [{"task_id": "Mbpp/249", "solution": "def intersection_array(arr1, arr2):\n    \"\"\"\n    Function to find the intersection of two arrays\n    \n    Args:\n    arr1: First array\n    arr2: Second array\n    \n    Returns:\n    List: Intersection of the two arrays\n    \"\"\"\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1 & set2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["", "zm", null, "QkDxdG", "Xe", "ertYo", 14, "gv"], ["zm", "guWZdvsBGL", "QUGweiSK", "l", "QkDxdG", "xsQS", "ertYo", "Fvp", ""]]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    # Function to find the ASCII value of a given character\n    \n    # Check if the input is a single character\n    if len(char) != 1:\n        return \"Please enter a single character\"\n    \n    # Find and return the ASCII value of the character\n    return ord(char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def sum_of_even_numbers_squares(n):\n    return (n * (n + 1) * (2 * n + 1)) // 3\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(num1, num2):\n    if num1 >= num2:\n        return num1\n    else:\n        return num2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    \"\"\"\n    Subtracts elements of tuple2 from corresponding elements in tuple1 and returns a new tuple.\n    \n    Args:\n    tuple1: First input tuple\n    tuple2: Second input tuple, must have the same length as tuple1\n    \n    Returns:\n    Tuple: Result of element-wise subtraction of tuple2 from tuple1.\n    \n    Example:\n    subtract_elements((1, 2, 3), (4, 5, 6))  # Output: (-3, -3, -3)\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = tuple(a - b for a, b in zip(tuple1, tuple2))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, n):\n    if k == 0 or n == 0:\n        return 0\n\n    effective_k = k % len(arr)\n    max_sum = float('-inf')\n    \n    for i in range(len(arr)):\n        current_sum = 0\n        for j in range(n):\n            index = (i + j) % len(arr)\n            current_sum += arr[index]\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 10, 20], 3, 2]], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(human_years):\n    \"\"\"Calculates a dog's age in dog years.\n\n    Args:\n        human_years (int): The dog's age in human years.\n\n    Returns:\n        int: The dog's age in dog years.\n    \"\"\"\n    if human_years <= 2:\n        return human_years * 10.5\n    else:\n        return 21 + (human_years - 2) * 4", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "from collections import Counter\n\ndef validate(num):\n    digit_frequency = Counter(str(num))\n    for digit in digit_frequency:\n        if int(digit_frequency[digit]) > int(digit):\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(elements, n, i, k):\n    dp = [0] * n\n    dp[i] = elements[i]\n    \n    for index in range(i):\n        if elements[index] < elements[i]:\n            dp[i] = max(dp[i], dp[index] + elements[i])\n    \n    for index in range(i, k):\n        for j in range(index):\n            if elements[j] < elements[index]:\n                dp[index] = max(dp[index], dp[j] + elements[index])\n        dp[index] += elements[k]\n    \n    return max(dp)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "Here's the modified code with the requested changes:\n\ndef dict_filter(d, n):\n    \"\"\"\n    Filters the dictionary to include entries with values greater than or equal to n.\n\n    Parameters:\n    d (dict): Input dictionary.\n    n (int): Threshold value.\n\n    Returns:\n    dict: Filtered dictionary.\n\n    Raises:\n    TypeError: If the input `d` is not a dictionary or `n` is not an integer.\n    \"\"\"\n    # Check if the input dictionary is valid\n    if not isinstance(d, dict):\n        raise TypeError(\"Input `d` must be a dictionary.\")\n\n    # Check if the input value `n` is a valid integer\n    if not isinstance(n, int):\n        raise TypeError(\"Input `n` must be an integer.\")\n\n    filtered_dict = {}\n    for key, value in d.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\n\ndef calculate_cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder using the formula: volume = \u03c0 * radius^2 * height.\n\n    Args:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Check if radius and height are positive numbers\n    if radius <= 0 or height <= 0:\n        raise ValueError(\"Radius and height must be positive numbers.\")\n    \n    # Calculate volume using the formula\n    volume = math.pi * radius**2 * height\n    \n    # Return the calculated volume\n    return volume\n\n# Test the function with different test cases\nif __name__ == \"__main__\":\n    # Test case 1: radius = 5, height = 10\n    volume1 = calculate_cylinder_volume(5, 10)\n    print(f\"Volume of cylinder with radius 5 and height 10 is: {volume1:.2f}\")\n\n    # Test case 2: radius = 0.5, height = 20\n    volume2 = calculate_cylinder_volume(0.5, 20)\n    print(f\"Volume of cylinder with radius 0.5 and height 20 is: {volume2:.2f}\")\n\n    # Test case 3: radius = 3, height = 0 (Edge case)\n    try:\n        volume3 = calculate_cylinder_volume(3, 0)\n        print(f\"Volume of cylinder with radius 3 and height 0 is: {volume3:.2f}\")\n    except ValueError as e:\n        print(e)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    def find_depth(dict, depth):\n        max_depth = depth\n        for value in dict.values():\n            if isinstance(value, dict):\n                temp = find_depth(value, depth + 1)\n                max_depth = max(max_depth, temp)\n        return max_depth\n\n    return find_depth(dictionary, 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[{"a": 1, "b": {"c": {"d": {"e": {"f": {}}}}}}]]}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def calculate_lateral_surface_area_of_cube(side_length):\n    \"\"\"\n    Calculates the lateral surface area of a cube given its side length.\n\n    Args:\n    - side_length: The length of the side of the cube.\n\n    Returns:\n    - The lateral surface area of the cube.\n    \"\"\"\n    \n    # Calculate the lateral surface area by multiplying the area of one face by the number of lateral faces (4 for a cube)\n    lateral_surface_area = 4 * (side_length ** 2)\n    return lateral_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must have the same length.\")\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] - list2[i])\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def reverse_numbers(num1: int, num2: int) -> tuple:\n    \"\"\"\n    Returns a tuple with the second number and then the first number.\n\n    Args:\n    num1: int - The first number.\n    num2: int - The second number.\n\n    Returns:\n    tuple: The second number followed by the first number.\n    \"\"\"\n    if not isinstance(num1, int) or not isinstance(num2, int):\n        raise TypeError(\"Input arguments must be integers.\")\n    \n    return num2, num1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, elem):\n    \"\"\"\n    Takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array\n    and the index position of the element (or -1 if the element is not found).\n    \n    Parameters:\n    arr (list): The input array to search.\n    elem: The element to search for in the array.\n    \n    Returns:\n    tuple: A tuple containing a boolean indicating if the element is found and its index if found, -1 otherwise.\n    \"\"\"\n    if not arr:\n        return (False, -1)\n    for i in range(len(arr)):\n        if arr[i] == elem:\n            return (True, i)\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def calculate_star_number(n):\n    \"\"\"\n    Calculate the star number based on the input number n.\n    \n    The star number is calculated by squaring the input number n and adding the square of (n-1).\n    \n    :param n: The input number to calculate the star number for.\n    :return: The calculated star number.\n    \"\"\"\n    return n**2 + (n-1)**2\n\n# Additional test cases\n\"\"\"\n>>> calculate_star_number(1)\n1\n>>> calculate_star_number(2)\n5\n>>> calculate_star_number(5)\n41\n\"\"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 == 0:\n            result += lst[i]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, num):\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    return sorted(products, reverse=True)[:num]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "def contains_a_followed_by_two_or_three_b(string):\n    if len(string) < 4:\n        return False\n    \n    for i in range(len(string) - 3):\n        if string[i] == 'a' and (string[i+1:i+4] == 'bbb' or string[i+1:i+5] == 'bbbb'):\n            return True\n    \n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(tuples):\n    aggregates = {}\n\n    for name, score in tuples:\n        if name in aggregates:\n            aggregates[name] += score\n        else:\n            aggregates[name] = score\n\n    max_aggregate = max(aggregates.items(), key=lambda x: x[1])\n    return max_aggregate", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def prime_factors(n):\n    # Function to calculate prime factors of a given number\n    \n    factors = []\n    \n    # Check for the edge case when n is negative\n    if n < 2:\n        return \"Please enter a positive integer greater than 1.\"\n    \n    # Check for prime factors of 2\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    \n    # Check for prime factors other than 2\n    for i in range(3, int(n**0.5)+1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        factors.append(n)\n    \n    return factors", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_power_sum(n):\n    \"\"\"\n    Calculates the sum of even-powered numbers up to n.\n\n    Parameters:\n    n (int): The number of terms to sum.\n\n    Returns:\n    int: The sum of even-powered numbers up to n.\n\n    >>> even_power_sum(2)\n    1056\n    >>> even_power_sum(3)\n    8832\n    \"\"\"\n\n    if n < 0:\n        return \"Invalid input: n must be a positive integer\"\n\n    result = 0\n    for i in range(1, n+1):\n        result += (2*i)**5\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_elements_before_tuple_element(input_tuple, element):\n    count = 0\n    for i in input_tuple:\n        if i == element:\n            return count\n        count += 1\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    def merge(arr, left, mid, right):\n        count = 0\n        left_subarray = arr[left:mid+1]\n        right_subarray = arr[mid+1:right+1]\n        i = j = 0\n\n        for k in range(left, right+1):\n            if i < len(left_subarray) and (j >= len(right_subarray) or left_subarray[i] <= right_subarray[j]):\n                arr[k] = left_subarray[i]\n                i += 1\n            else:\n                arr[k] = right_subarray[j]\n                j += 1\n                count += mid - left + 1 - i\n\n        return count\n\n    def merge_sort_and_count(arr, left, right):\n        count = 0\n\n        if left < right:\n            mid = (left + right) // 2\n            count += merge_sort_and_count(arr, left, mid)\n            count += merge_sort_and_count(arr, mid + 1, right)\n            count += merge(arr, left, mid, right)\n\n        return count\n\n    return merge_sort_and_count(arr, 0, len(arr) - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "def count_binary_seq(n):\n    \"\"\"\n    Counts the number of valid binary sequences with 2n bits.\n    \n    Parameters:\n    n (int): The number of bits in the sequence. \n    \n    Returns:\n    int: The number of valid binary sequences.\n    \"\"\"\n    def count_binary_seq_helper(bit_count, first_half_sum, second_half_sum):\n        # Base case when 2n bits have been processed\n        if bit_count == 2*n:\n            # Check if the difference between the sums is zero\n            if first_half_sum == second_half_sum:\n                return 1\n            else:\n                return 0\n        \n        # Recursive calls for setting the bit to 0 and 1\n        return count_binary_seq_helper(bit_count+1, first_half_sum, second_half_sum+((-1)**bit_count)) + \n               count_binary_seq_helper(bit_count+1, first_half_sum+((-1)**bit_count), second_half_sum)\n    \n    # Call the helper function with initial sums of 0\n    return count_binary_seq_helper(0, 0, 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "from typing import List\n\ndef all_unique(lst: List) -> bool:\n    \"\"\"\n    Function to check if all elements in a list are unique.\n\n    Args:\n    lst: A list of elements to check for uniqueness.\n\n    Returns:\n    True if all elements are unique, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # or True, depending on the requirement for an empty list\n\n    unique_elements = set(lst)\n  \n    return len(unique_elements) == len(lst)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    word_list = []\n    for phrase in words:\n        splitted_words = phrase.split(' ')\n        for word in splitted_words:\n            if word.startswith('P') or word.startswith('p'):\n                word_list.append(word)\n    \n    if len(word_list) >= 2:\n        return tuple(word_list[:2])\n    else:\n        return tuple(word_list)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/295": [{"task_id": "Mbpp/295", "solution": "def sum_div(n):\n    if n == 0:\n        return 0\n    div_sum = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            div_sum += i\n            if i != n // i:\n                div_sum += n // i\n    return div_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    result = []\n    sublist = []\n    for i, element in enumerate(lst):\n        if i % n == 0:\n            result.append(sublist)\n            sublist = []\n        sublist.append(element)\n    if sublist:\n        result.append(sublist)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def find_max_number(nums):\n    # Initialize the maximum number as None\n    max_num = None\n    \n    # Iterate through each element in the list\n    for num in nums:\n        # Check if the element is a numerical value\n        if isinstance(num, (int, float)):\n            # If the maximum number has not been set yet, set it to the current element\n            if max_num is None:\n                max_num = num\n            else:\n                # If the current element is greater than the maximum number, update the maximum number\n                if num > max_num:\n                    max_num = num\n    \n    # Handle the case where there are no numerical values in the list\n    if max_num is None:\n        return \"No numerical values found\"\n    \n    return max_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "from typing import List, Any, Tuple\n\ndef rear_extract(tuples_list: List[Tuple[Any, ...]]) -> List[Any]:\n    \"\"\"\n    Extracts the rear element from each tuple in the given list of tuples.\n    \n    Args:\n        tuples_list (list): List of tuples\n        \n    Returns:\n        list: List containing the rear elements of each tuple\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    rear_elements = []\n    for t in tuples_list:\n        if not isinstance(t, tuple):\n            raise TypeError(\"Input must be a list of tuples\")\n        if len(t) < 1:\n            raise ValueError(\"Tuple must have at least one element\")\n        \n        rear_elements.append(t[-1])\n    \n    return rear_elements", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculates the volume of a cone given its radius and height.\n\n    Args:\n        radius (float): The radius of the cone's base.\n        height (float): The height of the cone.\n\n    Raises:\n        ValueError: If radius or height is not a positive value.\n\n    Returns:\n        float: The volume of the cone.\n    \"\"\"\n    if radius <= 0 or height <= 0:\n        raise ValueError(\"Radius and height must be positive values.\")\n    \n    volume = (1/3) * math.pi * pow(radius, 2) * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "import math\n\ndef highest_Power_of_2(n):\n    exponent = int(math.log(n, 2))\n    return 2**(exponent)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "import math\n\ndef find(num1, num2):\n    return math.floor(num1 / num2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length_of_lists(lists):\n    \"\"\"\n    Returns the length of the longest list in the input list of lists, along with the corresponding list.\n    \n    Args:\n    lists (list): A list of lists.\n    \n    Returns:\n    tuple: A tuple containing the length of the longest list and the corresponding list.\n    \"\"\"\n    \n    if not lists:\n        return 0, []\n    \n    max_length = 0\n    max_length_list = []\n    \n    for sublist in lists:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_length_list = sublist\n    \n    return max_length, max_length_list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_list(lst, L):\n    if len(lst) < L:\n        return tuple(lst), ()\n    return tuple(lst[:L]), tuple(lst[L:])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    return n | (n + 1) if n & (n + 1) else (n << 1) | 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[255]]}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "def otherside_rightangle(a, b):\n    \"\"\"\n    >>> otherside_rightangle(8,7)\n    10.63014581273465\n    >>> otherside_rightangle(4,3)\n    5.0\n    >>> otherside_rightangle(15,7)\n    16.55294535724685\n    \"\"\"\n    return (a**2 + b**2) ** 0.5", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\r\n    memo = {0: 1, 1: 1}\r\n    for i in range(2, n + 1):\r\n        memo[i] = memo[i - 1] * i\r\n\r\n    binomial_sum = 0\r\n    for k in range(0, n + 1, 2):\r\n        binomial_sum += int(memo[n] / (memo[k] * memo[n - k]))\r\n    return binomial_sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list_helper(nested_list):\n    result = []\n    for element in nested_list:\n        if isinstance(element, list):\n            result.extend(flatten_list_helper(element))\n        else:\n            result.append(element)\n    return result\n\ndef flatten_list(nested_list):\n    return flatten_list_helper(nested_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_sum_of_odd_numbers(n):\n    sum_of_squares = 0\n    for odd_number in range(1, 2*n+1, 2):\n        sum_of_squares += odd_number ** 2\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def decagonal_number(n):\n    if n <= 0:\n        return \"Please enter a positive number for n\"\n    else:\n        decagonal_num = n * (3 * n - 2)\n        return decagonal_num\n\n# Test cases\nprint(decagonal_number(1))  # 10\nprint(decagonal_number(2))  # 30\nprint(decagonal_number(5))  # 150\nprint(decagonal_number(-3))  # Please enter a positive number for n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Performs element-wise division operation between two tuples of the same length.\n\n    Args:\n        tuple1 (tuple): Tuple of integers\n        tuple2 (tuple): Tuple of integers\n\n    Returns:\n        tuple: Tuple containing the result of dividing elements from tuple1 by elements from tuple2\n    \"\"\"\n    # Input validation: Check if tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must be of the same length\")\n\n    # Perform element-wise division and return the result as a tuple\n    result = tuple(x // y for x, y in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 3, 3], [5, 2, 3, 4]]]}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(string):\n    tuple_of_characters = ()\n    for char in string:\n        tuple_of_characters += (char,)\n    return tuple_of_characters", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["hello   world"]]}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "from typing import Dict\n\n\ndef find_lucas(n: int, memo: Dict[int, int]) -> int:\n    \"\"\"\n    Return the nth Lucas number, where Lucas numbers are an integer sequence\n    where each number is the sum of the two preceding ones.\n\n    Args:\n    - n (int): The index of the Lucas number to compute.\n    - memo (Dict[int, int]): A dictionary to store the already computed Lucas numbers.\n\n    Returns:\n    - int: The nth Lucas number.\n\n    Examples:\n    >>> find_lucas(9, {})\n    76\n    >>> find_lucas(0, {})\n    2\n    >>> find_lucas(4, {})\n    7\n    >>> find_lucas(3, {})\n    4\n    \"\"\"\n\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    if n in memo:\n        return memo[n]\n\n    memo[n] = find_lucas(n-1, memo) + find_lucas(n-2, memo)\n    return memo[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct(tup):\n    seen = set()\n    for element in tup:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "from typing import List, Tuple\n\ndef find_min_product_of_tuples(tuple_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from pairs of tuples within a given list.\n\n    Args:\n    - tuple_list (List[Tuple[int, int]]): A list of tuples containing integer pairs.\n\n    Returns:\n    - int: The minimum product found among all tuple pairs.\n    \"\"\"\n    min_product = float('inf')  # Initialize minimum product to positive infinity\n    for first_num, second_num in tuple_list:\n        product = first_num * second_num  # Calculate product for each tuple pair\n        if product < min_product:  # Compare with current minimum product\n            min_product = product  # Update minimum product if necessary\n    return min_product  # Return the minimum product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def max_sum_using_equation(n: int) -> int:\n    \"\"\"\n    Calculate the maximum sum using the given equation.\n    \n    Args:\n        n (int): The input value.\n        \n    Returns:\n        int: The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return max(max_sum_using_equation(n//2) + max_sum_using_equation(n//3) + max_sum_using_equation(n//4) + max_sum_using_equation(n//5), n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/396": [{"task_id": "Mbpp/396", "solution": "def check_char(s):\n    return \"Valid\" if s[0] == s[-1] else \"Invalid\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(num1, num2, num3):\n    \"\"\"\n    >>> median_numbers(25, 55, 65)\n    55.0\n    \"\"\"\n    sorted_numbers = sorted([num1, num2, num3])\n    if num1 == num2 or num1 == num3:  # Handling equal numbers\n        return num1\n    elif num2 == num3:  # Handling equal numbers\n        return num2\n    return sorted_numbers[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "from collections import defaultdict\n\ndef first_non_repeating_character(string: str) -> str:\n    count = defaultdict(int)\n    for char in string:\n        count[char] += 1\n\n    for char in string:\n        if count[char] == 1:\n            return char\n    \n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists in a tuple.\n\n    Parameters:\n    - tuplex (tuple): The tuple to check.\n    - element: The element to check for existence within the tuple.\n\n    Returns:\n    - bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    # Check if the element exists in the tuple\n    return element in tuplex", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_string):\n    return [format_string.format(elem) for elem in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "from typing import List, Dict\n\ndef convert_list_dictionary(list1: List[str], list2: List[str], list3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    if len(list1) != len(list2) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n        \n    return [{key: {value: nested_value}} for key, value, nested_value in zip(list1, list2, list3)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], [false, true, false, true, true, false, false], []]]}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(arr):\n    \"\"\"\n    >>> sum_of_digits([10, 20, 4, 5, 'b', 70, 'a'])\n    19\n    >>> sum_of_digits([10, 2, 56])\n    14\n    \"\"\"\n    def is_number(n):\n        try:\n            int(n)\n            return True\n        except ValueError:\n            return False\n\n    if not isinstance(arr, list):\n        return \"Input is not a list\"\n    \n    total = 0\n    for num in arr:\n        if is_number(num):\n            num = abs(int(num))\n            total += sum(int(digit) for digit in str(num))\n        else:\n            return \"Input contains non-integer values\"\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[10, -5, "abc", 0, 3.14]]]}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    \"\"\"\n    >>> Find_Max([['A'],['A','B'],['A','B','C']])\n    ['A', 'B', 'C']\n    >>> Find_Max([[1],[1,2],[1,2,3]])\n    [1, 2, 3]\n    >>> Find_Max([[1,1],[1,2,3],[1,5,6,1]])\n    [1, 5, 6, 1]\n    \"\"\"\n    return max(lst, key=len)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/407": [{"task_id": "Mbpp/407", "solution": "```\ndef rearrange_to_get_next_bigger_number(number):\n    digits_in_number = [int(digit) for digit in str(number)]\n    length_of_number = len(digits_in_number)\n    i = length_of_number - 2\n    \n    # Find the first digit from right to left that is smaller than the digit to its right\n    while i >= 0 and digits_in_number[i] >= digits_in_number[i + 1]:\n        i -= 1\n    \n    # If no such digit exists, the given number is already the largest possible number\n    if i == -1:\n        return False\n    \n    # Find the smallest digit to the right of digits_in_number[i] that is larger than digits_in_number[i]\n    j = length_of_number - 1\n    while digits_in_number[j] <= digits_in_number[i]:\n        j -= 1\n    \n    # Swap digits_in_number[i] and digits_in_number[j]\n    digits_in_number[i], digits_in_number[j] = digits_in_number[j], digits_in_number[i]\n    \n    # Sort the digits_in_number to the right of digits_in_number[i] in ascending order\n    digits_in_number[i + 1:] = sorted(digits_in_number[i + 1:])\n    \n    # Convert the list of digits_in_number back into an integer\n    next_bigger_number = int(''.join(map(str, digits_in_number)))\n    \n    return next_bigger_number\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "from typing import List, Union\n\ndef min_val(lst: List[Union[int, float]]) -> Union[int, float, None]:\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n    \"\"\"\n    result = None\n    for val in lst:\n        if isinstance(val, (int, float)):\n            if result is None or val < result:\n                result = val\n        else:\n            raise TypeError(\"Input list must contain only integers or floats.\")\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(numbers):\n    \"\"\"\n    Computes the cube of each element in the input list.\n\n    Args:\n    numbers (list): Input list containing integers.\n\n    Returns:\n    list: List containing the cubes of individual elements.\n    Raises:\n    TypeError: If the input list contains non-integer elements.\n    \"\"\"\n    if not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"Input list must contain only integers.\")\n    return [x ** 3 for x in numbers]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2.5, 3, -4.7, 5, 6, 7, -8.9]]]}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(number):\n    \"\"\"\n    Determine whether the parity of a given number is odd.\n    Args:\n        number (int): The number to check.\n    Returns:\n        bool: True if the number is odd, False otherwise.\n    \"\"\"\n    return bool(number & 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/431": [{"task_id": "Mbpp/431", "solution": "from typing import List, Union\n\ndef common_element(list1: List, list2: List) -> Union[bool, None]:\n    \"\"\"\n    Checks if two lists have at least one common element.\n    \n    Args:\n    list1 (List): The first list.\n    list2 (List): The second list.\n    \n    Returns:\n    Union[bool, None]: True if there is at least one common element, None if any list is empty, False otherwise.\n    \"\"\"\n    if not list1 or not list2:  # If either list is empty, return None\n        return None\n    \n    if list1 == list2:  # If both lists are the same, return True\n        return True\n    \n    set1 = set(list1)  # Convert the first list to a set for faster lookup\n    \n    for item in list2:\n        if item in set1:  # Check if the element exists in the set\n            return True  # If found, return True\n    \n    return False  # If no common element found, return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surface_area_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given its side length.\n\n    Args:\n    - side_length: a positive integer representing the side length of the cube\n\n    Returns:\n    - surface_area: an integer representing the total surface area of the cube\n    \"\"\"\n    total_surface_area = 6 * (side_length**2)\n    return total_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(nums):\n    \"\"\"\n    Filter odd numbers from a list of integers.\n\n    Args:\n        nums (list of int): A list of integers.\n\n    Returns:\n        list of int: A list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def average_cubed_numbers(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n        \n    average = sum / n\n    return average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the shell sort algorithm\n    \"\"\"\n    size = len(arr)\n    gap = size // 2\n\n    while gap > 0:\n        for i in range(gap, size):\n            current_element = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > current_element:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = current_element\n        gap //= 2\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def check_overlap(seq1, seq2):\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    if set1.intersection(set2):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def find_minimum(x: int, y: int) -> int:\n    \"\"\"\n    This function takes two integers as input and returns the minimum of the two.\n\n    Args:\n    x (int): The first integer input.\n    y (int): The second integer input.\n\n    Returns:\n    int: The minimum of the two input integers.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Inputs must be integers\")\n\n    if x < y:\n        return x\n    elif y < x:\n        return y\n    else:\n        return x  # or y, since they are equal. This can be adjusted based on the desired behavior.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(input_strings: tuple[str]) -> list[str]:\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n        input_strings (tuple[str]): Tuple of strings.\n\n    Returns:\n        list[str]: List containing the rear index element of each string.\n    \"\"\"\n    return [string[-1] for string in input_strings]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    \"\"\"\n    >>> round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])\n    243\n    >>> round_and_sum([5,2,9,24.3,29])\n    345\n    >>> round_and_sum([25.0,56.7,89.2])\n    513\n    \"\"\"\n    rounded_numbers = [round(num) for num in numbers]\n    sum_rounded = sum(rounded_numbers)\n    return sum_rounded", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5]]]}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_sum_of_even_numbers(n):\n    \"\"\"\n    Calculates the cube sum of the first n even natural numbers.\n\n    Args:\n    n: an integer representing the number of even natural numbers to consider.\n\n    Returns:\n    The cube sum of the first n even natural numbers.\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    cube_sum = 0\n    for i in range(1, 2 * n + 1):\n        cube_sum += (2 * i) ** 3\n\n    return cube_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tup: Tuple[str, str, int, str]) -> str:\n    delimiter = \"-\"\n    concatenated_string = delimiter.join(str(elem) for elem in tup)\n    return concatenated_string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(lst, n):\n    \"\"\"\n    Extracts the nth element from each tuple in the given list of tuples.\n\n    Args:\n    lst (list): List of tuples.\n    n (int): Index of the element to extract.\n\n    Returns:\n    list: List containing the nth elements from each tuple.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n    if n < 0 or n >= len(lst[0]):\n        raise ValueError(\"Index is out of bounds for tuple elements\")\n    return [t[n] for t in lst]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def find_max_product_pair(nums):\n    \"\"\"\n    Finds a pair with the highest product from a given array of integers.\n    \n    Args:\n    nums - List of integers\n    \n    Returns:\n    Tuple containing the pair with the highest product\n    \"\"\"\n    # Input validation\n    if not all(isinstance(num, int) for num in nums):\n        raise ValueError(\"Input list must contain only integers\")\n    \n    if len(nums) < 2:\n        raise ValueError(\"List must have at least two elements\")\n    \n    max_product = float('-inf')\n    pair = None\n    \n    # Using while loop instead of nested for loops\n    i = 0\n    while i < len(nums):\n        j = i + 1\n        while j < len(nums):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                pair = (nums[i], nums[j])\n            j += 1\n        i += 1\n    \n    if pair is None:\n        raise ValueError(\"No pair found with a positive product\")\n    \n    return pair", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if a given number is greater than all elements in a given array.\n\n    Args:\n    arr (list): List of numbers.\n    num (int): Number to check against.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([2, 3, 4, 5, 6], 8)\n    True\n    >>> check_greater([9, 7, 4, 8, 6, 1], 11)\n    True\n    \"\"\"\n    return all(num > element for element in arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format(date):\n    parts = date.split(\"-\")\n    return \"-\".join([parts[2], parts[1], parts[0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/400": [{"task_id": "Mbpp/400", "solution": "from collections import Counter\n\ndef extract_freq(tuples_list):\n    \"\"\"\n    Extracts the number of unique tuples from the given list of tuples.\n    \n    Args:\n    tuples_list: List of tuples\n    \n    Returns:\n    int: Number of unique tuples in the list\n    \"\"\"\n    tuples_freq = Counter(tuples_list)\n    return len(tuples_freq)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b):\n    \"\"\"\n    Function to find the median length of a trapezium given the lengths of the two parallel sides (bases).\n    \n    Args:\n    a, b: int or float, lengths of the two parallel sides (bases) of the trapezium.\n    \n    Returns:\n    float, the median length of the trapezium.\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Lengths of the sides must be positive numbers.\")\n    return (a + b) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def get_negative_numbers(numbers):\n    \"\"\"\n    Returns a list of negative numbers from the given list.\n    \n    Arguments:\n    numbers -- a list of integers\n    \n    Returns:\n    a list of negative integers\n    \"\"\"\n    return [num for num in numbers if num < 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculates the directrix of a parabola in standard form (y = ax^2 + bx + c).\n    \n    Parameters:\n    a (int): Coefficient of x^2\n    b (int): Coefficient of x\n    c (int): Constant term\n    \n    Returns:\n    int: Directrix of the parabola\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' cannot be zero.\")\n    \n    # Calculate focal length\n    focal_length = abs(b) / (2 * a)\n    \n    # Calculate directrix\n    directrix = c - focal_length\n    \n    return directrix", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(lst):\n    result = \"\"\n    for num in lst:\n        result += str(num)\n    return int(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    \"\"\"\n    Removes odd numbers from a given list.\n\n    Parameters:\n        lst (list): The input list.\n\n    Returns:\n        list: A new list containing only even numbers.\n        \n    Examples:\n        >>> remove_odd([1, 2, 3])\n        [2]\n        >>> remove_odd([2, 4, 6])\n        [2, 4, 6]\n        >>> remove_odd([10, 20, 3])\n        [10, 20]\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/438": [{"task_id": "Mbpp/438", "solution": "def find_bidirectional_pairs(arr):\n    pair_count = 0\n    pairs = set()\n    \n    for num1 in arr:\n        for num2 in arr:\n            if num1 == num2 * -1 and (num1, num2) not in pairs and (num2, num1) not in pairs:\n                pair_count += 1\n                pairs.add((num1, num2))\n    \n    return pair_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication(tup1, tup2):\n    \"\"\"\n    Performs index-wise multiplication of tuple elements in the given two tuples.\n    \"\"\"\n    if len(tup1) != len(tup2):\n        raise ValueError(\"Tuples must be of the same length\")\n    result_tuple = []\n    for i in range(len(tup1)):\n        result_tuple.append((tup1[i][0] * tup2[i][0], tup1[i][1] * tup2[i][1]))\n    return tuple(result_tuple)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]]]}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n    - sentence: A string representing the input sentence.\n\n    Returns:\n    - A tuple (start_position, end_position, adverb), where:\n      - start_position: The start position of the adverb in the sentence.\n      - end_position: The end position of the adverb in the sentence.\n      - adverb: The adverb found in the sentence.\n    \"\"\"\n    words = sentence.split()\n    for idx, word in enumerate(words):\n        clean_word = word.strip('!?.,;:')\n        if clean_word.endswith('ly'):\n            return (sentence.find(word), sentence.find(word) + len(word) - 1, clean_word)\n    # If no adverb is found, return an error message\n    raise ValueError(\"No adverb found in the input sentence.\")\n\n# Example usage:\ntry:\n    position = find_adverb_position(\"She sings beautifully.\")\n    print(\"Adverb found:\", position)\nexcept ValueError as e:\n    print(\"Error:\", e)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_element_in_tuple(tup, elem):\n    count = 0\n    for item in tup:\n        if item == elem:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    Returns the elementwise 'and' operation result between two tuples.\n\n    Args:\n    tuple1 (tuple): First input tuple.\n    tuple2 (tuple): Second input tuple.\n\n    Returns:\n    tuple: Tuple containing the result of elementwise 'and' operation.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    result = [elem1 & elem2 for elem1, elem2 in zip(tuple1, tuple2)]\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/442": [{"task_id": "Mbpp/442", "solution": "def positive_count(arr):\n    \"\"\"\n    Returns the ratio of positive numbers in an array of integers.\n\n    Args:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of positive numbers in the array.\n    \"\"\"\n    count_positives = sum(num > 0 for num in arr)\n    return count_positives / len(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_digit(num):\n    \"\"\"\n    Returns the last digit of a given number.\n\n    Args:\n    num (int): The number to find the last digit of.\n\n    Returns:\n    int: The last digit of the given number.\n    \"\"\"\n    return abs(num) % 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def even_indices(lst):\n    return [lst[i] for i in range(len(lst)) if i % 2 == 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n\n    a, b, c = 3, 0, 2\n    for i in range(3, n+1):\n        next_perrin = a + b\n        a, b, c = b, c, next_perrin\n    \n    return c", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, size):\n    \"\"\"\n    >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8)\n    ['practice', 'solution']\n    >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 6)\n    ['Python']\n    >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 9)\n    ['exercises']\n    \"\"\"\n    return [string for string in string_list if len(string) == size]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "from typing import List, Any\n\ndef find_minimum_sublist(sublists: List[List[Any]]) -> List[Any]:\n    if not sublists:\n        return []\n\n    minimum_sublist = sublists[0]\n    for sublist in sublists:\n        if len(sublist) < len(minimum_sublist):\n            minimum_sublist = sublist\n\n    return minimum_sublist", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    result = ''\n    for char in string:\n        if not char.isupper():\n            result += char\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Returns a new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        # Using string slicing\n        reversed_string = string[::-1]\n        # Appending reversed string to the new list\n        reversed_list.append(reversed_string)\n    return reversed_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(rectangle_length: int, rectangle_width: int) -> int:\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        rectangle_length (int): The length of the rectangle.\n        rectangle_width (int): The width of the rectangle.\n\n    Returns:\n        int: The area of the rectangle.\n    \"\"\"\n    return rectangle_length * rectangle_width", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/461": [{"task_id": "Mbpp/461", "solution": "def count_upper_case(string: str) -> int:\n    \"\"\"\n    Count the number of uppercase characters in a given string.\n\n    Examples:\n    >>> count_upper_case('PYthon')\n    1\n    >>> count_upper_case('BigData')\n    1\n    >>> count_upper_case('program')\n    0\n    \"\"\"\n\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def has_31_days(monthnumb):\n    if monthnumb < 1 or monthnumb > 12:\n        raise ValueError(\"Invalid month number\")\n\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n\n    return monthnumb in months_with_31_days", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    \"\"\"\n    >>> remove_whitespaces(' Google    Flutter ')\n    'GoogleFlutter'\n    >>> remove_whitespaces(' Google    Dart ')\n    'GoogleDart'\n    >>> remove_whitespaces(' iOS    Swift ')\n    'iOSSwift'\n    \"\"\"\n    return string.replace(' ', '')\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "def generate_combinations(index, partial_combination):\n    if index == len(lst):\n        return [partial_combination]\n    combinations = []\n    combinations.extend(generate_combinations(index+1, partial_combination))\n    combinations.extend(generate_combinations(index+1, partial_combination + [lst[index]]))\n    return combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def remove_empty_items(dictionary):\n    return {key: value for key, value in dictionary.items() if value}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def extract_first_element(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise ValueError(\"Input must be a list of sublists.\")\n\n    return [sublist[0] for sublist in lst]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "import math\n\ndef sumOfFactors(n):\n    \"\"\"\n    Returns the sum of even factors of a given number n.\n    \n    >>> sumOfFactors(18)\n    26\n    >>> sumOfFactors(30)\n    48\n    >>> sumOfFactors(6)\n    8\n    \"\"\"\n    # Initialize the sum of even factors\n    sum_of_even_factors = 0\n    \n    # Iterate through all numbers from 1 to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the sum\n                sum_of_even_factors += i\n            # Check if the corresponding factor is even\n            if n // i % 2 == 0 and n // i != i:\n                # Add the even corresponding factor to the sum\n                sum_of_even_factors += n // i\n    \n    return sum_of_even_factors", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "def text_match_wordz(string):\n    words = string.split()\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product(nums):\n    \"\"\"\n    Find the maximum product subarray within the given list.\n\n    Time complexity: O(n), where n is the length of the input list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The maximum product subarray.\n\n    Raises:\n    None.\n    \"\"\"\n\n    if len(nums) == 0:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    result = max_product\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        result = max(result, max_product)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    result = []\n    start = 0\n    while True:\n        start = s.find('\"', start)\n        if start == -1:\n            break\n        end = s.find('\"', start+1)\n        if end == -1:\n            break\n        result.append(s[start + 1:end])\n        start = end + 1\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    return all(lst[i+1] - lst[i] == 1 for i in range(len(lst)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return set1.intersection(set2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "from typing import List\n\ndef max_product(numbers: List[int]) -> int:\n    \"\"\"\n    Returns the maximum product formed by multiplying numbers of an increasing subsequence of the given array.\n\n    Args:\n    numbers: List of integers.\n\n    Returns:\n    Maximum product formed by multiplying numbers of an increasing subsequence.\n    \"\"\"\n\n    # Check for empty input list\n    if not numbers:\n        return 0\n\n    # Initialize variables\n    max_product_value = float('-inf')\n    current_product = 1\n    previous_number = float('-inf')\n\n    # Iterate through the numbers in the list\n    for number in numbers:\n        # If the current number is greater than the previous number, add it to the subsequence\n        if number > previous_number:\n            current_product *= number\n        else:\n            # Compare the product of the subsequence with the maximum product found so far\n            max_product_value = max(max_product_value, current_product)\n\n            # Reset the current product to the current number\n            current_product = number\n\n        # Update the previous number\n        previous_number = number\n\n    # Compare the product of the subsequence with the maximum product found so far\n    max_product_value = max(max_product_value, current_product)\n\n    return max_product_value", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[3, -5, 2, 6, -1, 4, -3]]]}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase_substrings(input_string):\n    if not input_string:\n        return input_string\n\n    modified_string = input_string\n    substrings_to_remove = []\n\n    # Identify lowercase substrings\n    start_index = 0\n    while start_index < len(modified_string):\n        if modified_string[start_index].islower():\n            end_index = start_index + 1\n            while end_index < len(modified_string) and modified_string[end_index].islower():\n                end_index += 1\n            substrings_to_remove.append(modified_string[start_index:end_index])\n            start_index = end_index\n        else:\n            start_index += 1\n\n    # Remove lowercase substrings from the original string\n    for substring in substrings_to_remove:\n        modified_string = modified_string.replace(substring, \"\")\n\n    return modified_string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(nums, n):\n    remainder = nums[0]\n    for num in nums[1:]:\n        remainder = (remainder * num) % n\n    return remainder", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2000000], 10001]]}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    \"\"\"\n    Returns the sum of the largest contiguous sublist in the given list.\n\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([-3, -4, 5, -2, -3, 2, 6, -4], 8)\n    8\n    >>> max_sub_array_sum([-4, -5, 6, -3, -4, 3, 7, -5], 8)\n    10\n    \"\"\"\n    max_ending_here = arr[0]\n    max_so_far = arr[0]\n  \n    for i in range(1, n):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def remove_duplicates(nums):\n    # Convert input list to a set to remove duplicates efficiently\n    nums_set = set(nums)\n    \n    # Convert the set back to a list to preserve the original order\n    nums_unique = list(nums_set)\n    \n    return nums_unique", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(lst, n):\n    \"\"\"\n    Counts the number of pairs in a list whose XOR value is odd.\n\n    Parameters:\n    lst (list): List of integers.\n    n (int): Length of the list.\n\n    Returns:\n    int: Count of pairs whose XOR value is odd.\n    \"\"\"\n    odd_remainders = 0\n    even_remainders = 0\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            even_remainders += 1\n        else:\n            odd_remainders += 1 \n          \n    return odd_remainders * even_remainders", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "from itertools import combinations\n\ndef count_Pairs(nums, n):\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \n    Args:\n    nums (list of int): List of integers.\n    n (int): Length of the list.\n\n    Returns:\n    int: Number of possible unordered pairs.\n    \"\"\"\n    \n    # Input validation\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        raise ValueError(\"Input 'nums' must be a list of integers.\")\n    if not isinstance(n, int) or n <= 1:\n        raise ValueError(\"Input 'n' must be an integer greater than 1.\")\n\n    # Initialize count\n    count = 0\n\n    # Generate combinations of pairs\n    pairs = combinations(nums, 2)\n\n    # Count pairs where elements are unequal\n    for pair in pairs:\n        if pair[0] != pair[1]:\n            count += 1\n\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10, 7, 6], 2]]}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    sorted_list = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise(numbers):\n    pairwise_sums = []\n    for i in range(len(numbers)):\n        pairwise_sum = numbers[i-1] + numbers[i+1]\n        pairwise_sums.append(pairwise_sum)\n    return tuple(pairwise_sums)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def check_sublist(master_list, sublist):\n    return all(item in master_list for item in sublist)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit(num):\n    \"\"\"\n    Returns the first digit of a given number.\n\n    Examples:\n    >>> first_Digit(123)\n    1\n    >>> first_Digit(0)\n    0\n    \"\"\"\n    if num == 0:\n        return 0\n    else:\n        return int(str(abs(num))[0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "Certainly! Could you please provide the code that needs modification along with the teacher's requirements?", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_of_tuples(t1, t2):\n    set1 = set(t1)\n    set2 = set(t2)\n    union_set = set1 | set2\n    sorted_tuple = tuple(sorted(union_set))\n    return sorted_tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "Here is a basic structure of the function code that follows the teacher's requirements:\n\n```\ndef find_last_digit_factorial(n):\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    last_digit = factorial % 10\n    return last_digit\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_case(input_string):\n    # Function to toggle the case of each character in a string\n    \n    toggled_string = \"\" # initialize an empty string for the toggled string\n    \n    # iterate through each character in the input string\n    for char in input_string:\n        if char.isupper(): # check if the character is uppercase\n            toggled_string += char.lower() # convert the character to lowercase and append it to the toggled string\n        else:\n            toggled_string += char.upper() # convert the character to uppercase and append it to the toggled string\n    \n    return toggled_string # return the toggled string\n\n# The function takes an input string and toggles the case of each character in the string before returning the modified string.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def sum_of_digit_differences(num1, num2):\n    \"\"\"\n    Calculates the sum of the per-digit differences between two integers.\n\n    Parameters:\n    num1 (int): The first integer\n    num2 (int): The second integer\n\n    Returns:\n    int: The sum of per-digit differences between the two integers\n    \"\"\"\n\n    if not (isinstance(num1, int) and isinstance(num2, int)):\n        raise ValueError(\"Both inputs must be integers\")\n\n    # Ensure both numbers are positive\n    num1 = abs(num1)\n    num2 = abs(num2)\n\n    # Convert the numbers to strings for iteration\n    num1_str = str(num1)\n    num2_str = str(num2)\n\n    # Find the length of the longer number\n    max_length = max(len(num1_str), len(num2_str))\n\n    # Iterate through each digit and calculate the difference\n    total_diff = 0\n    for i in range(max_length):\n        digit1 = int(num1_str[i]) if i < len(num1_str) else 0\n        digit2 = int(num2_str[i]) if i < len(num2_str) else 0\n        total_diff += abs(digit1 - digit2)\n\n    return total_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    # Function to sort each sublist of strings in a given list of lists\n    for sublist in list_of_lists:\n        sublist.sort()\n\n    return list_of_lists", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(array):\n    \"\"\"\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 2, 3, 4])\n    3\n    \"\"\"\n    if len(array) == 0: # handle empty array case\n        return None\n    \n    min_value = float('inf')\n    max_value = float('-inf')\n\n    for num in array:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n\n    return min_value + max_value", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(nums):\n    \"\"\"\n    >>> unique_product([10, 20, 30, 40, 20, 50, 60, 40]) \n    720000000\n    >>> unique_product([7, 8, 9, 0, 1, 1]) \n    0\n    \"\"\"\n    unique_numbers_set = set(nums)\n    result = 1\n    if len(unique_numbers_set) == 0:\n        return 0\n    for num in unique_numbers_set:\n        result *= num\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split_string(input_string):\n    # Handle edge case of an empty string\n    if not input_string:\n        return []\n    \n    # Use list comprehension to split the string into individual characters\n    return [char for char in input_string]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def max_sublist_length(input_list):\n    max_length = 0\n    for sublist in input_list:\n        length = len(sublist)\n        if length > max_length:\n            max_length = length\n    return max_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n: int) -> int:\n    \"\"\"\n    Calculate the sum of digits in a given integer.\n\n    Args:\n        n (int): The integer to calculate the sum of its digits.\n\n    Returns:\n        int: The sum of digits of the input integer.\n\n    Examples:\n        >>> sum_digits(345)\n        12\n        >>> sum_digits(12)\n        3\n        >>> sum_digits(97)\n        16\n    \"\"\"\n    digit_sum = 0\n    while n > 0:\n        digit_sum += n % 10\n        n //= 10\n    return digit_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "Sure, could you please provide the code that needs to be modified according to the teacher's requirements?", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    \"\"\"\n    Check if a list is sorted in ascending order\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i+1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower(s):\n    \"\"\"\n    >>> is_lower(\"InValid\")\n    'invalid'\n    >>> is_lower(\"TruE\")\n    'true'\n    >>> is_lower(\"SenTenCE\")\n    'sentence'\n    \"\"\"\n    if s.islower():\n        return s\n    else:\n        return s.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    \"\"\"\n    Calculates the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n    \n    Args:\n    n: An integer representing the number of natural numbers.\n    \n    Returns:\n    An integer representing the calculated difference.\n    \"\"\"\n    sum_cubes = 0\n    sum_natural = 0\n    for i in range(1, n+1):\n        sum_cubes += i**3\n        sum_natural += i\n    \n    return sum_cubes - sum_natural", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/574": [{"task_id": "Mbpp/574", "solution": "from math import pi\n\ndef surfacearea_cylinder(r, h):\n    return round(2*pi*r*r + 2*pi*r*h, 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def is_prime(num):\n    \"\"\"\n    Checks if a given number is prime.\n    \n    Args:\n        num (int): The number to check.\n    \n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    \"\"\"\n    Generates the n-th Newman prime number.\n    \n    Args:\n        n (int): The index of the Newman prime number to generate.\n    \n    Returns:\n        int: The n-th Newman prime number.\n    \"\"\"\n    newman_primes = [7]\n    candidate = 7\n    while len(newman_primes) < n:\n        candidate += 2 * sum(newman_primes) + 2\n        while not is_prime(candidate):\n            candidate += 2\n        newman_primes.append(candidate)\n    return newman_primes[n-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "from typing import List\n\ndef validate_lists(list1: List, list2: List, list3: List) -> None:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length\")\n\ndef interleave_lists(list1: List, list2: List, list3: List) -> List:\n    validate_lists(list1, list2, list3)\n    \n    result = [val for sublist in zip(list1, list2, list3) for val in sublist]\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    result_set = set(tuple1) ^ set(tuple2)\n    return tuple(sorted(result_set))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[21, 11, 25, 26], [26, 34, 21, 36]]], "plus_fail_tests": [[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], [10, 10, 20, 20, 30, 30, 40, 40, 50, 50]]]}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    # Check for invalid inputs\n    if base_edge <= 0 or height <= 0:\n        raise ValueError(\"Base edge and height must be positive values.\")\n\n    # Calculate base area\n    base_area = base_edge ** 2\n\n    # Calculate lateral area\n    # Using Pythagorean theorem to find the slant height of the triangular faces\n    slant_height = ((base_edge / 2) ** 2 + height ** 2) ** 0.5\n    # Calculate lateral area of each triangular face and sum them up\n    lateral_area_triangular = 3 * (1/2) * base_edge * slant_height\n    # Calculate lateral area of the square faces\n    lateral_area_square = 4 * base_edge * (height / 2)\n    # Total lateral area\n    lateral_area = lateral_area_triangular + lateral_area_square\n\n    # Calculate total surface area\n    total_surface_area = base_area + lateral_area\n\n    return total_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    Extracts even numbers from a nested tuple.\n\n    Args:\n    nested_tuple: a tuple containing either integers or tuples of integers\n\n    Returns:\n    A tuple containing only the even integers extracted from the input nested_tuple\n    \"\"\"\n    def is_even(num):\n        return num % 2 == 0\n\n    if not isinstance(nested_tuple, tuple):\n        return nested_tuple\n\n    result = []\n    for item in nested_tuple:\n        if isinstance(item, tuple):\n            extracted = extract_even(item)\n            if extracted:\n                result.append(extracted)\n        elif is_even(item):\n            result.append(item)\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/582": [{"task_id": "Mbpp/582", "solution": "def is_empty_dict(input_dict):\n    if not isinstance(input_dict, dict):\n        return False\n    return not bool(input_dict)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def get_top_n_items(dataset, n):\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_dataset[:n] if len(sorted_dataset) >= n else sorted_dataset", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number.\n    \n    Catalan numbers represent the number of valid expressions containing n pairs of parentheses.\n\n    Args:\n    n (int): The index of the Catalan number to calculate.\n\n    Returns:\n    int: The nth Catalan number.\n\n    Raises:\n    ValueError: If n is a non-positive integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    elif n == 0:\n        return 1\n    \n    # Initialize the Catalan number as 1\n    catalan = 1\n    \n    # Iterate through values from 0 to n-1 to calculate the nth Catalan number\n    for i in range(0, n):\n        # Update the Catalan number using the recurrence relation\n        catalan = catalan * 2 * (2 * i + 1) / (i + 2)\n    \n    return int(catalan)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted to a tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    return tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr: List[int], n: int) -> List[int]:\n    if n > len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def difference_between_first_even_and_first_odd_numbers(lst_of_numbers):\n    first_even_number = None\n    first_odd_number = None\n    for num in lst_of_numbers:\n        if num % 2 == 0 and first_even_number is None:\n            first_even_number = num\n        elif num % 2 != 0 and first_odd_number is None:\n            first_odd_number = num\n        if first_even_number is not None and first_odd_number is not None:\n            return abs(first_even_number - first_odd_number)\n    return 'List does not contain both even and odd numbers.'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(input_list):\n    \"\"\"\n    Function to interchange the first and last elements in a list.\n\n    Args:\n    input_list (list): Input list with elements to swap.\n\n    Returns:\n    list: List with first and last elements swapped.\n\n    Examples:\n    >>> swap_List([12, 35, 9, 56, 24])\n    [24, 35, 9, 56, 12]\n    >>> swap_List([1, 2, 3])\n    [3, 2, 1]\n    \"\"\"\n    if len(input_list) <= 1:  # Handling edge cases where list is empty or has 1 element\n        return input_list\n\n    input_list[0], input_list[-1] = input_list[-1], input_list[0]  # Swapping first and last elements\n    return input_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    \"\"\"\n    >>> big_diff([1,2,3,4])\n    3\n    >>> big_diff([4,5,12])\n    8\n    \"\"\"\n    return max(nums) - min(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth_element(arr1, arr2, k):\n    \"\"\"\n    Given two sorted arrays arr1 and arr2, the function finds the kth element from the two arrays.\n\n    Args:\n    arr1: First sorted array\n    arr2: Second sorted array\n    k: Index of the element to find\n\n    Returns:\n    The kth element from the two arrays\n    \"\"\"\n    # Error handling for empty arrays or out of bounds k\n    if not arr1 or not arr2 or k < 1 or k > len(arr1) + len(arr2):\n        return None\n    \n    # Pointers for arrays arr1 and arr2\n    p1, p2 = 0, 0\n    \n    while True:\n        # If one of the arrays is exhausted, return the kth element from the other array\n        if p1 == len(arr1):\n            return arr2[p2 + k - 1]\n        if p2 == len(arr2):\n            return arr1[p1 + k - 1]\n        \n        # If k is reduced to 1, return the minimum of the current elements at pointers p1 and p2\n        if k == 1:\n            return min(arr1[p1], arr2[p2])\n\n        # Divide k into two halves\n        mid = k // 2\n        \n        # Calculate new pointers within bounds\n        new_p1 = min(p1 + mid, len(arr1)) - 1\n        new_p2 = min(p2 + mid, len(arr2)) - 1\n\n        # Compare the elements at new pointers and adjust k and pointers accordingly\n        if arr1[new_p1] <= arr2[new_p2]:\n            k -= new_p1 - p1 + 1\n            p1 = new_p1 + 1\n        else:\n            k -= new_p2 - p2 + 1\n            p2 = new_p2 + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/595": [{"task_id": "Mbpp/595", "solution": "def min_Swaps(binary1, binary2):\n    ones_in_binary1 = binary1.count('1')\n    zeros_in_binary1 = binary1.count('0')\n    ones_in_binary2 = binary2.count('1')\n    zeros_in_binary2 = binary2.count('0')\n    \n    if ones_in_binary1 != ones_in_binary2 or zeros_in_binary1 != zeros_in_binary2:\n        return \"Not Possible\"\n    \n    mismatch_count = 0\n    for i in range(len(binary1)):\n        if binary1[i] != binary2[i]:\n            mismatch_count += 1\n            \n    return mismatch_count // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["111", "000"]], "plus_fail_tests": [["1111111111111111111111111111111111111111111111111111111111111111", "0000000000000000000000000000000000000000000000000000000000000000"]]}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def sum_Of_product(n):\n    def factorial(num):\n        if num == 0:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    def binomial_coefficient(n, k):\n        return factorial(n) / (factorial(k) * factorial(n - k))\n    \n    coefficients = [binomial_coefficient(n, k) for k in range(n + 1)]\n    result = sum(coefficients[i] * coefficients[i+1] for i in range(len(coefficients) - 1))\n    \n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def get_column(matrix, column_index):\n    \"\"\"\n    Retrieves a specified column from a given matrix.\n\n    Args:\n        matrix (list of lists): The input matrix.\n        column_index (int): The index of the column to retrieve.\n\n    Returns:\n        list: The specified column from the matrix.\n\n    Raises:\n        ValueError: If the input matrix is empty or the column index is out of range.\n\n    Example:\n        matrix = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]\n        column_index = 1\n        print(get_column(matrix, column_index))  # Output: [2, 5, 8]\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"Input matrix is empty\")\n\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n\n    if column_index < 0 or column_index >= num_cols:\n        raise ValueError(\"Column index is out of range\")\n\n    column = []\n    for row in matrix:\n        if column_index < len(row):\n            column.append(row[column_index])\n        else:\n            raise ValueError(\"Column index is out of range for some rows\")\n\n    return column", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "```python\ndef findPerfectSquares(start, end):\n    result = []\n    \n    # Loop through the range of numbers from start to end\n    for num in range(start, end+1):\n        # Check if the number is a perfect square\n        if (num**0.5).is_integer():\n            result.append(num)\n    \n    return result\n\n# Test cases\nprint(findPerfectSquares(1, 10))  # Output: [1, 4, 9]\nprint(findPerfectSquares(10, 20))  # Output: [16]\nprint(findPerfectSquares(5, 25))   # Output: [9, 16, 25]\n\n# Alternative approach: Instead of using a for loop, we can use list comprehension to optimize the code\n# result = [num for num in range(start, end+1) if (num**0.5).is_integer()]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number using the Bell triangle method.\n\n    Parameters:\n    n (int): The index of the Bell number to be calculated.\n\n    Returns:\n    int: The nth Bell number.\n\n    Examples:\n    >>> bell_number(5)\n    52\n    >>> bell_number(10)\n    115975\n    \"\"\"\n    bell_triangle = [[1]]  # Initialize the Bell triangle with the first row [1]\n    for row_index in range(1, n + 1):\n        prev_row = bell_triangle[-1]  # Get the previous row of the triangle\n        new_row = [prev_row[-1]]  # Initialize the new row with the last element of the previous row\n        for col_index in range(1, row_index + 1):\n            # Calculate each element of the new row by summing the previous element of the new row\n            # and the corresponding element of the previous row\n            new_row.append(new_row[-1] + prev_row[col_index - 1])\n        bell_triangle.append(new_row)  # Append the new row to the Bell triangle\n    return bell_triangle[n][n - 1]  # Return the nth Bell number", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(input_str, pattern):\n    try:\n        match = pattern.search(input_str) # accepting the regex pattern as a compiled regex object\n        if match:\n            return match.group(), match.start(), match.end()\n        else:\n            return None, None, None\n    except:\n        return \"Error: Regex pattern does not match anything in the input string.\" # Adding error handling for cases where the regex pattern does not match anything in the input string.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def is_prime(num):\n    # Check for input validation\n    if not isinstance(num, int):\n        return \"Invalid input: input should be an integer\"\n    \n    # Return False directly if the input is negative or 0\n    if num <= 0:\n        return False\n    \n    # Implement more efficient algorithm for checking prime numbers\n    if num == 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    char_seen = set()\n    for char in s:\n        if char in char_seen:\n            return char\n        else:\n            char_seen.add(char)\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(number):\n    \"\"\"\n    Check if a given number is even.\n    \n    Args:\n    number (int): The number to be checked.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Examples:\n    >>> is_Even(4)\n    True\n    >>> is_Even(7)\n    False\n    >>> is_Even(-2)\n    True\n    >>> is_Even(0)\n    True\n    \"\"\"\n    return number % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    # Split the IP address into its individual parts using the dot as a delimiter\n    parts = ip_address.split('.')\n    \n    # Initialize an empty list to store the modified parts of the IP address\n    new_parts = []\n    \n    # Iterate over each part of the IP address\n    for part in parts:\n        # Remove leading zeros from each part of the IP address by converting it to an integer and then back to a string\n        new_part = str(int(part))\n        \n        # Append the modified part to the new_parts list\n        new_parts.append(new_part)\n    \n    # Join the modified parts back into a single string using the dot as a delimiter\n    new_ip_address = '.'.join(new_parts)\n    \n    # Return the modified IP address\n    return new_ip_address", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n    Returns True if the given number is an Armstrong number, False otherwise.\n    \"\"\"\n    num = number\n    num_of_digits = len(str(num))\n    sum_of_powers = 0\n    while num > 0:\n        digit = num % 10\n        sum_of_powers += digit ** num_of_digits\n        num //= 10\n    return sum_of_powers == number\n\n# Additional test cases\n# Test with single digit numbers\nassert armstrong_number(5) == True\nassert armstrong_number(9) == True\n\n# Test with numbers that are the sum of cubes of their digits\nassert armstrong_number(370) == True\nassert armstrong_number(153) == True\n\n# Test with negative numbers\nassert armstrong_number(-153) == False\nassert armstrong_number(-1634) == False\n\nprint(\"All test cases passed!\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    return sum(sum(tup) for tup in tuple_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "from typing import List\n\ndef div_list(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Divides elements of list1 by elements of list2 element-wise.\n    \n    Args:\n    list1 (list): List of numbers.\n    list2 (list): List of numbers.\n    \n    Returns:\n    list: List containing the result of element-wise division of list1 by list2.\n    \"\"\"\n    result = []\n    if len(list1) != len(list2):\n        raise ValueError(\"Unequal lengths of lists\")\n    for num1, num2 in zip(list1, list2):\n        if num2 == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        result.append(num1 / num2)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_divisible_subset(numbers):\n    \"\"\"\n    Finds the size of the largest subset such that every pair in the subset is divisible.\n    \n    >>> largest_divisible_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_divisible_subset([10, 5, 3, 15, 20])\n    3\n    >>> largest_divisible_subset([18, 1, 3, 6, 13, 17])\n    4\n    \"\"\"\n    if not numbers:\n        return 0\n\n    # Initialize the dynamic programming array with zeroes and set the first element to 1\n    dp = [0] * len(numbers)\n    dp[0] = 1\n\n    # Iterate to find the largest divisible subset\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] % numbers[j] == 0:  # Check divisibility\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Find the maximum size of the subset\n    return max(dp) or 1  # Handle edge case of an empty list\n\n# Test cases for edge cases\nprint(largest_divisible_subset([]))  # Expected output: 0\nprint(largest_divisible_subset([7]))  # Expected output: 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    divisor = 5\n    while divisor * divisor <= n:\n        if n % divisor == 0 or n % (divisor + 2) == 0:\n            return False\n        divisor += 6\n    return True\n\ndef get_ludic(n):\n    ludic_numbers = []\n    prime_set = {2, 3, 5, 7, 11, 13, 17, 19}  # To store prime numbers\n\n    for i in range(1, n + 1):\n        if all(i % p == 0 for p in prime_set if p < i):\n            ludic_numbers.append(i)\n\n    return ludic_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(s):\n    \"\"\"\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    >>> reverse_words(\"java language\")\n    \"language java\"\n    >>> reverse_words(\"indian man\")\n    \"man indian\"\n    >>> reverse_words(\"\")\n    \"\"\n    >>> reverse_words(\"   hello   world  \")\n    \"world hello\"\n    >>> reverse_words(\"!!! Hello, World !!!\")\n    \"!!! World, Hello !!!\"\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return \" \".join(words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns the modified list.\n    \n    Parameters:\n    lst (list): The input list from which an element needs to be removed.\n    k (int): The index of the element to be removed.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the range of list indices.\n    \"\"\"\n    \n    # Check if k is within the range of the list indices\n    if not 0 <= k < len(lst):\n        raise IndexError(\"Index k is out of range\")\n    \n    # Use list slicing to remove the k'th element\n    return lst[:k] + lst[k+1:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath\n\ndef polar_rect(r, theta):\n    z = r * cmath.exp(1j * theta)\n    return z.real, z.imag", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def transpose_sublists(lst):\n    if any(len(sublst) != 2 for sublst in lst):\n        return \"Invalid input format. Each sublist must contain exactly two elements.\"\n    \n    return [list(t) for t in zip(*lst)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math\n\ndef radian_degree(degrees):\n    radians = degrees * (math.pi/180)\n    return radians", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def calculate_averages(tuples):\n    averages = []\n    for tup in tuples:\n        total = sum(tup)\n        average = total / len(tup)\n        averages.append(average)\n    return averages", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    return tuple([x % y for x, y in zip(tuple1, tuple2)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def find_median_sorted_arrays(nums1, nums2):\n    if not nums1 and not nums2:\n        raise ValueError(\"Input lists cannot be empty\")\n    \n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must have the same length\")\n    \n    merged_list = nums1 + nums2\n    merged_list.sort()\n    \n    length = len(merged_list)\n    middle_index = length // 2\n    \n    if length % 2 == 0:\n        median = (merged_list[middle_index] + merged_list[middle_index - 1]) / 2\n    else:\n        median = merged_list[middle_index]\n    \n    return median", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "import re\n\ndef extract_numbers(s):\n    numbers = re.findall(r'\\d+', s)\n    return numbers\n\ndef remove_numbers(s):\n    s = re.sub(r'\\d+', '', s)\n    return s\n\ndef move_num(string):\n    numbers = extract_numbers(string)\n    string = remove_numbers(string)\n    return string + ''.join(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def split(numbers):\n    even_numbers = []\n    for number in numbers:\n        if number % 2 == 0:\n            even_numbers.append(number)\n    return even_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    return '%20'.join(string.split())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["I love Coding     "]]}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(string):\n    return string.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    if not nums:\n        return []\n    if n < 0:\n        return []\n    \n    return [num ** n for num in nums]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0.9876346699284253, 1.405118970978401], -50]]}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "def triangle_area(radius):\n    if radius < 0:\n        return None\n    height = radius\n    base = 2 * radius\n    return 0.5 * base * height", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    if len(lst) == 0:\n        return []\n    new_list = [num for num in lst if num != 0]\n    new_list.extend([0] * lst.count(0))\n    return new_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_sum(nums, n):\n    xor_sum = 0\n    for i in range(n):\n        xor_sum ^= nums[i]\n    return 2 * xor_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_whitespaces(string):\n    \"\"\"\n    Replace whitespaces in a string with underscores.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with whitespaces replaced by underscores.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n\n    import re\n    string = re.sub(r'\\s+', '_', string)\n    string = re.sub(r'(_+)', ' ', string)\n\n    return string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(arr: list) -> list:\n    \"\"\"\n    Returns a sorted list in ascending order using the heap sort algorithm.\n\n    Parameters:\n    arr (list): List of integers to be sorted\n\n    Returns:\n    list: Sorted list in ascending order\n    \"\"\"\n    def heapify(arr: list, n: int, i: int) -> None:\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sample_nam(name_list):\n    return sum(len(name) for name in name_list if not name[0].islower())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_array_upto_k(arr, k):\n    return arr[:k][::-1] + arr[k:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Returns the nth nonagonal number.\n\n    >>> is_nonagonal(10)\n    325\n    >>> is_nonagonal(15)\n    750\n    \"\"\"\n    if n < 1:\n        return \"Invalid input. n should be a positive integer.\"\n    return n * (7*n - 5) / 2", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "import math\n\ndef calculate_wind_chill_index(wind_speed, temperature):\n    \"\"\"\n    Calculates wind chill index based on wind speed and temperature.\n    Formula: wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * wind_speed^0.16 + 0.3965 * temperature * wind_speed^0.16\n    Formula assumes wind_speed is in km/h and temperature is in Celsius.\n    \"\"\"\n\n    # Convert wind speed from km/h to m/s\n    wind_speed = wind_speed * (1000/3600)\n\n    # Convert temperature from Celsius to Fahrenheit\n    temperature = (temperature * 9/5) + 32\n\n    # Calculate wind chill index using formula\n    wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * math.pow(wind_speed, 0.16) + 0.3965 * temperature * math.pow(wind_speed, 0.16)\n\n    # Round the result to the next integer\n    wind_chill_index = math.ceil(wind_chill_index)\n\n    return wind_chill_index\n\n# Test the function with different scenarios\n\n# Scenario 1: Wind speed = 10 km/h, Temperature = 20\u00b0C\nprint(calculate_wind_chill_index(10, 20)) # Expected output: 17\n\n# Scenario 2: Wind speed = 5 km/h, Temperature = -5\u00b0C\nprint(calculate_wind_chill_index(5, -5)) # Expected output: 25\n\n# Scenario 3: Wind speed = 0 km/h, Temperature = 10\u00b0C\nprint(calculate_wind_chill_index(0, 10)) # Expected output: 46\n\n# Scenario 4: Wind speed = 20 km/h, Temperature = 30\u00b0C\nprint(calculate_wind_chill_index(20, 30)) # Expected output: 20", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(string):\n    if not string.strip():\n        return False\n\n    words = string.split()\n\n    return any('z' in word[1:-1] for word in words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def no_profit_no_loss(cost_price, selling_price):\n    return cost_price == selling_price", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/640": [{"task_id": "Mbpp/640", "solution": "import re\n\ndef remove_parenthesis(string):\n    pattern = r'\\([^)]*\\)'\n    return re.sub(pattern, '', string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup: tuple, dictionary: dict) -> tuple:\n    lst = list(tup)\n    lst.append(dictionary)\n    return tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverage(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = (dp[i][j-1] * (j) + matrix[i][j]) / (j + 1)\n            elif j == 0:\n                dp[i][j] = (dp[i-1][j] * (i) + matrix[i][j]) / (i + 1)\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1] / (m + n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data(data, min_height, min_weight):\n    \"\"\"\n    Filter the input data based on minimum height and weight criteria\n    \n    Args:\n    data: dictionary containing student names as keys and tuples of height and weight as values\n    min_height: minimum height criteria for filtering students\n    min_weight: minimum weight criteria for filtering students\n    \n    Returns:\n    filtered_data: dictionary containing student names as keys and tuples of height and weight as values that meet the height and weight criteria\n    \"\"\"\n    if not isinstance(data, dict) or not all(isinstance(v, tuple) and len(v) == 2 and isinstance(v[0], (int, float)) and isinstance(v[1], (int, float)) for v in data.values()):\n        return \"Invalid input data\"\n        \n    if not (isinstance(min_height, (int, float)) and isinstance(min_weight, (int, float))):\n        return \"Invalid input for minimum height and weight criteria\"\n        \n    filtered_data = {name: (height, weight) for name, (height, weight) in data.items() if height > min_height and weight > min_weight}\n    \n    if not filtered_data:\n        return \"No students meet the height and weight criteria\"\n        \n    return filtered_data\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[{}, 5.7, 64]]}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Returns the count of indices where the lists have the same values.\n\n    Args:\n    list1: First input list\n    list2: Second input list\n\n    Returns:\n    Count of indices where the lists have the same values\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must be of the same length\")\n    \n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def filter_even_numbers(input_tuple):\n    \"\"\"\n    This function takes a tuple of numbers as input and returns a new tuple containing only the even numbers from the input tuple.\n    If the input tuple has only one element, it returns an empty tuple.\n\n    Args:\n    input_tuple: Tuple of numbers\n\n    Returns:\n    Tuple of even numbers\n    \"\"\"\n    if len(input_tuple) == 1:\n        return ()\n    \n    return tuple(num for num in input_tuple if num % 2 == 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def remove_duplicates(lst):\n    i = 0\n    while i < len(lst)-1:\n        if lst[i] == lst[i+1]:\n            del lst[i]\n        else:\n            i += 1\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\n\ndef starts_with_vowel(string):\n    \"\"\"\n    Check if a given string starts with a vowel (case-insensitive).\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    pattern = '^[aeiou]', re.IGNORECASE\n    return re.match(pattern, string) is not None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "from typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    result = [x + y for x, y in zip(lst1, lst2)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "from itertools import combinations\n\ndef sum_Of_Subarray_Prod(nums):\n    \"\"\"\n    Finds the sum of products of all possible sublists of a given list using itertools.combinations\n    to generate combinations efficiently.\n    \n    Args:\n    nums: A list of integers.\n    \n    Returns:\n    An integer representing the sum of products of all possible sublists.\n    \n    Example:\n    >>> sum_Of_Subarray_Prod([1,2,3])\n    20\n    >>> sum_Of_Subarray_Prod([1,2])\n    5\n    >>> sum_Of_Subarray_Prod([1,2,3,4])\n    84\n    \"\"\"\n    result = 0\n    n = len(nums)\n    for length in range(1, n + 1):\n        for combo in combinations(nums, length):\n            product = 1\n            for num in combo:\n                product *= num\n            result += product\n    return result", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    if base < 0 or power < 0:\n        raise ValueError(\"Base and power must be non-negative.\")\n\n    result = pow(base, power)\n    sum_of_digits = sum(int(digit) for digit in str(result))\n    return sum_of_digits", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    result = {}\n    for i in range(0, len(tup)-1, 2):\n        result[tup[i]] = tup[i+1]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cone\n    :param radius: radius of the cone\n    :param height: height of the cone\n    :return: lateral surface area\n    \"\"\"\n    slant_height = math.sqrt(radius ** 2 + height ** 2)\n    lateral_surface_area = math.pi * radius * slant_height\n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "from collections import deque\n\ndef rotate_list(input_list, rotations):\n    if not input_list:\n        raise ValueError(\"Input list cannot be empty\")\n    if rotations < 0:\n        raise ValueError(\"Rotation count cannot be negative\")\n\n    input_deque = deque(input_list)\n    input_deque.rotate(rotations)\n    rotated_list = list(input_deque)\n    \n    return rotated_list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(edge_length):\n    \"\"\"\n    Calculate the area of a tetrahedron given the edge length.\n    \n    Args:\n    edge_length (float): The length of the edge of the tetrahedron.\n    \n    Returns:\n    float: The area of the tetrahedron.\n    \"\"\"\n    area = math.sqrt(3) * edge_length**2\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re\n\n#Extracts quoted text from a string\ndef extract_quotation(s):\n    quotes = re.findall(r'\\\"(.*?)\\\"|\\'(.*?)\\'', s)\n    result = [quote[0] if quote[0] else quote[1] for quote in quotes]\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Watch content '4k Ultra HD' resolution with 'HDR 10' Support"]], "plus_fail_tests": [["Quotation marks within single quotes: 'This is a \"quoted\" phrase'"]]}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(num):\n    \"\"\"\n    Toggle the bits of the number except the first and last bit.\n    \n    Args:\n    num: An integer representing the number whose middle bits need to be toggled.\n    \n    Returns:\n    An integer with the middle bits toggled.\n    \"\"\"\n    if not isinstance(num, int):\n        raise ValueError(\"Input is not a valid integer\")\n    \n    if num < 0:\n        raise ValueError(\"Input should be a positive integer\")\n    \n    # Create a mask with 1s in all positions except the first and last\n    mask = (1 << (num.bit_length() - 1)) - 1\n    mask ^= 3  # XOR with 3 to set first and last bits to 0\n    \n    # XOR the number with the mask to toggle the middle bits\n    return num ^ mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s):\n    # Check if all characters are the same using the `all` function\n    return all(char == s[0] for char in s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_for_none_values(data):\n    if any(element is None for element in data):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, val):\n    # Initialize low and high pointers\n    low = 0\n    high = len(arr)\n    \n    # Binary search to find insertion index\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] < val:\n            low = mid + 1\n        else:\n            high = mid\n    \n    # Return the index where 'val' should be inserted\n    return low", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Finds the index of the smallest triangular number with n digits.\n\n    Parameters:\n    n (int): The number of digits.\n\n    Returns:\n    int: The index of the smallest triangular number with n digits, or None if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return None\n\n    index = 1\n    triangular_number = 1\n\n    # Loop until the triangular number has n digits\n    while len(str(triangular_number)) < n:\n        index += 1\n        triangular_number = get_triangular_number(index)\n\n    # Return the index of the triangular number with n digits\n    return index", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    \"\"\"\n    Function to find numbers within a given range from startnum to endnum where every number is divisible by every digit it contains.\n\n    Args:\n    startnum (int): The starting number of the range.\n    endnum (int): The ending number of the range.\n\n    Returns:\n    List: List of numbers within the given range that meet the criteria.\n    \"\"\"\n\n    def is_divisible_by_all_digits(num):\n        for digit in str(num):\n            digit_int = int(digit)\n            if digit_int != 0 and num % digit_int != 0:\n                return False\n        return True\n\n    if startnum > endnum:\n        return []\n\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_all_digits(num):\n            result.append(num)\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    Finds the index of the first occurrence of a given number in a sorted array.\n\n    Args:\n    - arr: Sorted list of integers.\n    - target: Integer to search for.\n\n    Returns:\n    - Index of the first occurrence of the target in the array.\n    - Returns -1 if the target is not found.\n    \"\"\"\n    # Initialize the left and right pointers\n    left = 0\n    right = len(arr) - 1\n    result = -1  # Default value if target is not found\n\n    # Binary search algorithm\n    while left <= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Move to the left to find the first occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(input_list, input_tuple):\n    # Check if input_list is a list\n    if not isinstance(input_list, list):\n        return \"Error: First input must be a list\"\n    \n    # Check if input_tuple is a tuple\n    if not isinstance(input_tuple, tuple):\n        return \"Error: Second input must be a tuple\"\n    \n    # Append tuple elements to the list\n    for item in input_tuple:\n        input_list.append(item)\n    \n    return input_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(strings):\n    def convert_to_int(string):\n        try:\n            return int(string)\n        except ValueError:\n            return 0  # Handle non-numeric strings by returning 0\n\n    sorted_numbers = sorted(map(convert_to_int, strings))\n    return sorted_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    reverse_dict = {}\n    \n    for string in string_list:\n        reverse_string = string[::-1]\n        if reverse_string in reverse_dict:\n            count += reverse_dict[reverse_string]\n        \n        if string in reverse_dict:\n            reverse_dict[string] += 1\n        else:\n            reverse_dict[string] = 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def calculate_jacobsthal_number(n):\n    \"\"\"\n    Calculate the n-th Jacobsthal number using the Jacobsthal sequence.\n    \n    Args:\n    n: a non-negative integer for which Jacobsthal number is to be calculated\n    \n    Returns:\n    An integer corresponding to the Jacobsthal number for the given input n\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    previous1, previous2 = 0, 1\n    result = 0\n    for _ in range(2, n+1):\n        result = previous1 + 2*previous2\n        previous1, previous2 = previous2, result\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    >>> min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3)\n    [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    >>> min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1)\n    [('Ayesha', 9)]\n    \"\"\"\n    if k > len(records):\n        raise ValueError(\"k cannot be greater than the length of records\")\n    return sorted(records, key=lambda x: x[1])[:k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    result = []\n    for index in range(min(len(l1), len(l2), len(l3))):\n        if l1[index] == l2[index] == l3[index]:\n            result.append(l1[index])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Checks if the input array is a valid min heap.\n    :param arr: List of integers\n    :return: True if the input array is a min heap, False otherwise\n    \"\"\"\n    n = len(arr)\n    for i in range(n//2 - 1, -1, -1):\n        if not is_min_heap(arr, i):\n            return False\n    return True\n\ndef is_min_heap(arr, i):\n    \"\"\"\n    Checks if the subtree rooted at index i satisfies the min heap property.\n    :param arr: List of integers\n    :param i: Index of the root of the subtree\n    :return: True if the subtree rooted at index i satisfies the min heap property, False otherwise\n    \"\"\"\n    n = len(arr)\n    left_child = 2*i + 1\n    right_child = 2*i + 2\n    if left_child < n and arr[i] > arr[left_child]:\n        return False\n    if right_child < n and arr[i] > arr[right_child]:\n        return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(input_string):\n    if input_string.isspace():\n        return input_string\n    \n    capital_words = []\n    last_capital = -1\n    \n    for i in range(len(input_string)):\n        if input_string[i].isupper():\n            capital_words.append(input_string[last_capital+1:i])\n            last_capital = i\n    \n    final_word = input_string[last_capital+1:]\n    if final_word:\n        capital_words.append(final_word)\n    \n    return ' '.join(capital_words)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(nums):\n    \"\"\"\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([1, 1, -0.5, 0, 2, -2, -2])\n    -0.5\n    \"\"\"\n    if len(nums) < 2:\n        return None\n    sorted_nums = sorted(nums)  # Sort\n    return sorted_nums[1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, -0.5, 0, 2, -2, -2]]], "plus_fail_tests": []}], "Mbpp/746": [{"task_id": "Mbpp/746", "solution": "import math\n\nDEG_TO_RAD = math.pi / 180\n\ndef sector_area(radius, angle):\n    \"\"\"\n    Calculates the area of a sector given the radius and angle.\n\n    Args:\n        radius (float): The radius of the sector.\n        angle (float): The angle (in degrees) of the sector.\n\n    Returns:\n        float or None: The area of the sector if angle <= 360, otherwise returns None.\n    \"\"\"\n    angle = abs(angle % 360)  # handling negative angles and converting to positive equivalent\n    return 0.5 * radius ** 2 * angle * DEG_TO_RAD if angle <= 360 else None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def count_unique_sublists(lst):\n    if not lst:\n        return 0\n    \n    unique_sublists = {tuple(lst[i:j + 1]) for i in range(len(lst)) for j in range(i, len(lst))}\n    \n    return len(unique_sublists)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(nums):\n    \"\"\"\n    Return True if the list contains only one distinct element, otherwise return False\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1,2])\n    False\n    \"\"\"\n    return all(num == nums[0] for num in nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "import re\n\ndef is_decimal(s):\n    \"\"\"\n    >>> is_decimal('123.11')\n    True\n    >>> is_decimal('e666.86')\n    False\n    >>> is_decimal('3.124587')\n    False\n    >>> is_decimal('1.11')\n    True\n    >>> is_decimal('1.1.11')\n    False\n    \"\"\"\n    if not re.match(r'^\\s*-?\\d+\\.\\d{2}\\s*$', s):\n        return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["-123.11"]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def get_days_in_month(month_number):\n    # Dictionary to map month number to the number of days it contains\n    days_in_month = {\n        1: 31,\n        2: 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    \n    # Check if the month number is valid\n    if month_number < 1 or month_number > 12:\n        return \"Invalid month number\"\n    \n    # Return the number of days in the specified month\n    return days_in_month[month_number]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_difference_between_adjacent_elements(array: list, size: int) -> int:\n    \"\"\"\n    Find the minimum difference between adjacent elements in a sorted array.\n\n    Args:\n        array (list): A list of integers.\n        size (int): The size of the array.\n\n    Returns:\n        int: The minimum difference between adjacent elements.\n    \"\"\"\n    # Sort the array in ascending order\n    array.sort()\n    \n    # Initialize the minimum difference to positive infinity\n    min_difference = float('inf')\n    \n    # Iterate through the array to find the minimum difference between adjacent elements\n    for i in range(size - 1):\n        # Calculate the difference between adjacent elements\n        difference = array[i + 1] - array[i]\n        \n        # Update the minimum difference if the current difference is smaller\n        if difference < min_difference:\n            min_difference = difference\n            \n    # Return the minimum difference\n    return min_difference", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def count_digits(s):\n    \"\"\"\n    >>> count_digits('3wonders')\n    1\n    >>> count_digits('3wond-1ers2')\n    3\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length(s, k):\n    if not s or k < 0:\n        return \"Invalid input\"\n    \n    words = s.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def find_nth_polite(n):\n    \"\"\"\n    Find the nth polite number where polite numbers are the ones that have only 2's, 4's, 8's in their binary representation.\n    \n    Args:\n    n (int): The value of n for which we need to find the nth polite number.\n    \n    Returns:\n    int: The nth polite number.\n    \"\"\"\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if is_polite(num):\n            count += 1\n    return num\n\ndef is_polite(num):\n    \"\"\"\n    Helper function to check if a number is polite.\n    \n    Args:\n    num (int): The number to be checked for politeness.\n    \n    Returns:\n    bool: True if the number is polite, else False.\n    \"\"\"\n    while num > 1:\n        if num % 2 != 0:\n            return False\n        num /= 2\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression: str) -> bool:\n    parentheses = {\n        '(': ')',\n        '[': ']',\n        '{': '}'\n    }\n    stack = []\n\n    for char in expression:\n        if char in parentheses:\n            stack.append(char)\n        elif char in parentheses.values():\n            if not stack or char != parentheses[stack.pop()]:\n                return False\n\n    return not stack", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def common_elements(list1, list2):\n    if not list1 or not list2:\n        return []\n\n    set1 = set(list1)\n    set2 = set(list2)\n\n    return [item for item in set1 if item in set2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def sum_pairs_count(numbers, target_sum):\n    \"\"\"\n    Returns the count of pairs in the list 'numbers' whose sum is equal to 'target_sum'.\n    \"\"\"\n    sum_pairs = 0\n    nums_frequency = {}\n    \n    for number in numbers:\n        complement = target_sum - number\n        if complement in nums_frequency:\n            sum_pairs += nums_frequency[complement]\n            \n        if number in nums_frequency:\n            nums_frequency[number] += 1\n        else:\n            nums_frequency[number] = 1\n            \n    return sum_pairs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "import re\n\ndef find_substring_occurrence_and_position(main_string, substring):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n\n    Args:\n    main_string (str): The main string to search within.\n    substring (str): The substring to search for.\n\n    Returns:\n    tuple or None: A tuple containing the substring, its starting position, and its ending position if found,\n    otherwise None.\n    \"\"\"\n    if not isinstance(main_string, str) or not isinstance(substring, str):\n        raise ValueError(\"main_string and substring must be strings\")\n    occurrences = [(m.group(0), m.start(), m.end() - 1) for m in re.finditer(substring, main_string)]\n    return occurrences[0] if occurrences else None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n\n    Args:\n    lst (list): The input list.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \n    Raises:\n    TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n    \n    Args:\n    n: An integer representing the number of odd natural numbers.\n    \n    Returns:\n    Sum of the fourth power of the first n odd natural numbers.\n    \"\"\"\n    if n <= 0:\n        return \"Please enter a positive integer for n\"\n    \n    return sum([x ** 4 for x in range(1, (2 * n), 2)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested(input_tuple):\n    return tuple(item for item in input_tuple if not isinstance(item, tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "from itertools import combinations\n\ndef find_combinations(tuple_list):\n    comb_sum = list(set([(tup1[0] + tup2[0], tup1[1] + tup2[1]) for tup1, tup2 in combinations(tuple_list, 2)] +\n                        [(tup1[1] + tup2[0], tup1[0] + tup2[1]) for tup1, tup2 in combinations(tuple_list, 2)]))\n    return comb_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def multiply_even_odd(lst):\n    # Initialize variables for storing even and odd numbers\n    even_number, odd_number = None, None\n    \n    # Loop through the list to find both even and odd numbers\n    for num in lst:\n        if num % 2 == 0 and even_number is None:\n            even_number = num\n        elif num % 2 != 0 and odd_number is None:\n            odd_number = num\n        if even_number is not None and odd_number is not None:\n            break\n            \n    # Return the product of even and odd numbers if both are found, otherwise return None\n    return even_number * odd_number if even_number is not None and odd_number is not None else None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def create_tuple(input_list, input_string):\n    \"\"\"\n    Function to create a tuple by adding the elements of the list and the string provided as input.\n\n    Args:\n    input_list: List of elements\n    input_string: String input\n\n    Returns:\n    Tuple containing the elements of the list and the input string\n    \"\"\"\n\n    # Check if input_list is empty or not a list\n    if not input_list or not isinstance(input_list, list):\n        return \"Input list is empty or not a list\"\n\n    # Check if input_string is empty or not a string\n    if not input_string or not isinstance(input_string, str):\n        return \"Input string is empty or not a string\"\n\n    # Create a new tuple by adding the elements of the list and the string\n    new_tuple = tuple(input_list) + (input_string,)\n\n    return new_tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(number):\n    divisor_count = 0\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            divisor_count += 2 if i * i != number else 1\n    return divisor_count % 2 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "import re\n\ndef convert_input_to_tuple(input_string):\n    try:\n        if not isinstance(input_string, str):\n            raise ValueError(\"Input must be a string\")\n\n        input_format = re.compile(r'^\\(\\d+(,\\d+)*\\)$')\n        if not input_format.match(input_string):\n            raise ValueError(\"Invalid input format\")\n\n        input_tuple = eval(input_string)\n\n        if not all(isinstance(num, int) for num in input_tuple):\n            raise ValueError(\"Input must contain only integers\")\n\n        return input_tuple\n    except Exception as e:\n        return f\"Error: {e}\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    # Initialize the low and high variables to represent the range of indices to search\n    low = 0\n    high = len(arr) - 1\n    \n    # Perform binary search until the range of indices is valid\n    while low <= high:\n        # Calculate the mid index to divide the range in half\n        mid = (low + high) // 2\n        \n        # If the value at the mid index is less than the target value, update the low index to search the right half\n        if arr[mid] < value:\n            low = mid + 1\n        # If the value at the mid index is greater than or equal to the target value, update the high index to search the left half\n        else:\n            high = mid - 1\n    \n    # Return the final low index, which represents the correct position to insert the target value\n    return low", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, -90.20293226837086, -12.02758648076636, -35.964731488229475], false]]}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Calculates the sum of all odd-length subarrays in the given list of integers.\n\n    Args:\n    arr (list): List of integers.\n\n    Returns:\n    int: Sum of all odd-length subarrays.\n    \"\"\"\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        total_sum += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "from collections import Counter\n\ndef find_sum(lst):\n    \"\"\"\n    Calculates the sum of non-repeated elements in the given list.\n    \n    >>> find_sum([1,2,3,1,1,4,5,6])\n    21\n    >>> find_sum([1,10,9,4,2,10,10,45,4])\n    71\n    >>> find_sum([12,10,9,45,2,10,10,45,10])\n    78\n    \"\"\"\n    counts = Counter(lst)\n    non_repeated_elements = [num for num, count in counts.items() if count == 1]\n    return sum(non_repeated_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "from itertools import groupby\n\ndef pack_consecutive_duplicates(lst):\n    result = [list(group) for key, group in groupby(lst)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "def text_match_three(text):\n    for i in range(len(text)-2):\n        if text[i]=='a' and text[i+1]=='b' and text[i+2]=='b':\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/783": [{"task_id": "Mbpp/783", "solution": "def rgb_to_hsv(r, g, b):\n    # Normalize RGB values to be in the range [0, 1]\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    \n    # Calculate Cmax and Cmin\n    cmax = max(r, g, b)\n    cmin = min(r, g, b)\n    \n    # Calculate delta\n    delta = cmax - cmin\n    \n    # Calculate Hue\n    if delta == 0:\n        h = 0\n    elif cmax == r:\n        h = 60 * (((g - b) / delta) % 6)\n    elif cmax == g:\n        h = 60 * (((b - r) / delta) + 2)\n    elif cmax == b:\n        h = 60 * (((r - g) / delta) + 4)\n    \n    # Calculate Saturation\n    if cmax == 0:\n        s = 0\n    else:\n        s = delta / cmax\n    \n    # Calculate Value\n    v = cmax\n    \n    return h, s, v", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0, 1]]}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(arr):\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 != 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "from typing import Dict\n\ndef return_sum(input_dict: Dict[str, int]) -> int:\n    \"\"\"\n    Calculate the sum of all values in the given dictionary.\n\n    :param input_dict: Input dictionary with numeric values\n    :return: The sum of all values in the dictionary\n    \"\"\"\n    sum_of_values = 0\n    for value in input_dict.values():\n        if isinstance(value, int):\n            sum_of_values += value\n        else:\n            raise ValueError(\"Input dictionary should only contain numeric values.\")\n    return sum_of_values", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[{"-6.592133142656678": -74.66033573549664, "4.283511885784776": 29.179082806283958, "96.95801895498732": -63.94902533164137, "-43.659979177568474": -80.16037131046572, "-43.89754125964028": -88.34305526116584}]]}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    Function to count the number of equal numbers from three given integers.\n    \n    Args:\n    a, b, c: Integers to compare\n    \n    Returns:\n    count: Number of equal pairs among the three integers\n    \"\"\"\n    numbers = [a, b, c]\n    count = 0\n    for num in numbers:\n        if numbers.count(num) > 1:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\n\ndef find_emails(text):\n    pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    emails = re.findall(pattern, text)\n    return emails", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_of_odd_numbers(l, r):\n    if l > r:\n        return 0\n    else:\n        total = 0\n        for num in range(l, r + 1):\n            if num % 2 != 0:\n                total += num\n        return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    \"\"\"\n    Takes in a list of lists and returns the list with the highest sum of elements.\n    \n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \n    >>> max_sum_list([[3,2,1], [6,5,4], [12,11,10]])\n    [12, 11, 10]\n    \n    >>> max_sum_list([[2,3,1]])\n    [2, 3, 1]\n    \"\"\"\n    if not lists:\n        return []\n    \n    max_sum = sum(lists[0])\n    max_list = lists[0]\n    \n    for li in lists[1:]:\n        current_sum = sum(li)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = li\n            \n    return max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(lst):\n    count_even = 0\n    for num in lst:\n        if num % 2 == 0:\n            count_even += 1\n            \n    return count_even > 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def sum_array(arr):\n    if not isinstance(arr, list):\n        return \"Error: Input is not a valid array\"\n    \n    try:\n        return sum(arr)\n    except Exception as e:\n        return f\"Error: {e}\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_of_uppercase_chars(input_string):\n    if not input_string:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in input_string:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(nums):\n    if len(nums) == 0:\n        return None\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def find_last_position(arr, target):\n    # Binary search to efficiently find the last position of the element in the sorted array\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n# Additional edge cases and boundary values\nprint(find_last_position([1, 3, 5, 5, 5, 7, 8, 9], 5))  # Output should be 4\nprint(find_last_position([1, 3, 5, 5, 5, 7, 8, 9], 6))  # Output should be -1\nprint(find_last_position([1, 3, 5, 5, 5, 7, 8, 9], 1))  # Output should be 0\nprint(find_last_position([1, 3, 5, 5, 5, 7, 8, 9], 9))  # Output should be 7\nprint(find_last_position([1, 3, 5, 5, 5, 7, 8, 9], 10))  # Output should be -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "def is_perfect_square(num):\n    sqrt = math.sqrt(num)\n    return sqrt % 1 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(input_number, number_of_rotations):\n    # Perform left rotation by shifting the bits to the left by the given number of rotations\n    # Use bitwise left shift operation to achieve left rotations\n    # Modulo 0x100000000 to keep the result within 32-bit integer range\n    # Return the result\n    return (input_number << number_of_rotations) % 0x100000000", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    return sum(1 for item in lists if isinstance(item, list))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(s):\n    return ''.join([char for char in s if char != ' '])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "from typing import Tuple\n\ndef check_K(t: Tuple[int, ...], k: int) -> bool:\n    if not t:\n        raise ValueError(\"Tuple is empty.\")\n    \n    return k in t", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 5]]}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    for x, y in zip(tuple1, tuple2):\n        if y >= x:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates(coordinate):\n    x, y = coordinate\n    coordinates = []\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            coordinates.append([i, j])\n    return coordinates", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "import itertools\n\ndef combinations_colors(colors, n):\n    \"\"\"\n    Returns a list of all combinations (with repetition) of the elements in the given list 'colors' and length 'n'.\n    \"\"\"\n    if len(colors) == 0:\n        return \"Error: The input list 'colors' cannot be empty.\"\n    if not isinstance(n, int) or n <= 0:\n        return \"Error: The value of 'n' must be a positive integer.\"\n    \n    return list(itertools.product(colors, repeat=n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Args:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n    \"\"\"\n    if n == 0:  # Handle the case where n is zero\n        return (0, 0)\n\n    total_sum = 0\n    for i in range(1, n+1):\n        total_sum += i\n\n    average = total_sum / n if n != 0 else 0  # Check if n is not zero to avoid division by zero\n    return total_sum, average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}