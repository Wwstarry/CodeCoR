{"date": "2024-04-25 16:00", "hash": "ebe95df0d5220f00cedd6f4bddea35e4", "eval": {"Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def series(n):\n    total = 0\n    for i in range(n // 2 + 1):\n        total += (n - 2 * i)\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    if isinstance(d, dict) and d:\n        return 1 + max(dict_depth(v) for v in d.values())\n    return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_len = 0\n    max_element = []\n\n    for element in lst:\n        if len(element) > max_len:\n            max_len = len(element)\n            max_element = element\n\n    return max_element", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum(input):\n    n = len(input)\n    if n < 2:  # Check for input validation\n        return sum(input)\n\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    # Calculate maximum sum of increasing subsequence ending at each index\n    for i in range(n):\n        increasing[i] = input[i]\n        for j in range(i):\n            if input[i] > input[j] and increasing[i] < increasing[j] + input[i]:\n                increasing[i] = increasing[j] + input[i]\n\n    # Calculate maximum sum of decreasing subsequence starting at each index\n    for i in range(n - 1, -1, -1):\n        decreasing[i] = input[i]\n        for j in range(i + 1, n):\n            if input[i] > input[j] and decreasing[i] < decreasing[j] + input[i]:\n                decreasing[i] = decreasing[j] + input[i]\n\n    max_sum = 0\n    for i in range(n):\n        curr_sum = increasing[i] + decreasing[i] - input[i]\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n\n    return max_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def k_distinct(input_tuple):\n    if len(set(input_tuple)) == len(input_tuple):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float): The length of a side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n    \"\"\"\n    # The volume of a cube is given by side_length^3\n    volume = side_length ** 3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def max_sum(n):\n    # Base case\n    if n <= 0:\n        return 0\n    # Check if value is already calculated\n    if n in memo:\n        return memo[n]\n    # Calculate the maximum sum using the given equation\n    max_sum = max(max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5), n)\n    # Store the calculated value in memo\n    memo[n] = max_sum\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_product(nums):\n    max_product = float('-inf')\n    pair = ()\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                pair = (nums[i], nums[j])\n    \n    return pair", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/143": [{"task_id": "Mbpp/143", "solution": "def find_lists(tuple_list):\n    count = 0\n    for item in tuple_list:\n        if isinstance(item, list):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "import math\n\ndef count_binary_seq(n):\n    return math.factorial(2*n) / (math.factorial(n) ** 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(key_list, value_list, score_list):\n    result = []\n    for key, value, score in zip(key_list, value_list, score_list):\n        nested_dict = {key: {value: score}}\n        result.append(nested_dict)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def lapping(seq1, seq2):\n    for val1 in seq1:\n        if val1 in seq2:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    # Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n    # Return the first n elements\n    return sorted_lst[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    filtered_dict = {}\n    for key, value in dictionary.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "def volume_cylinder(radius, height):\n    return 3.141592653589793 * radius**2 * height", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    aggregates = {}\n    for name, score in lst:\n        if name in aggregates:\n            aggregates[name] += score\n        else:\n            aggregates[name] = score\n    max_aggregate = max(aggregates.values())\n    max_name = max(aggregates, key=aggregates.get)\n    return (max_name, max_aggregate)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    if isinstance(lst, str):\n        lst = lst.split(\"\\n\")\n    return [format_str.format(elem) for elem in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def flip(arr, k):\n    \"\"\"Helper function to flip the first k elements of an array.\"\"\"\n    i = 0\n    while i < k / 2:\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n        i += 1\n\ndef find_max_index(arr, n):\n    \"\"\"Helper function to find the index of the maximum element in the array.\"\"\"\n    mi = 0\n    for i in range(n):\n        if arr[i] > arr[mi]:\n            mi = i\n    return mi\n\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using pancake sort.\"\"\"\n    n = len(arr)\n    while n > 1:\n        mi = find_max_index(arr, n)\n        if mi != n - 1:\n            flip(arr, mi + 1)\n            flip(arr, n)\n        n -= 1\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        lucas_list = [2, 1]\n        for i in range(2, n + 1):\n            lucas_list.append(lucas_list[i - 1] + lucas_list[i - 2])\n        return lucas_list[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    flattened_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    return flattened_list\n\n# Testing the function\ntest_list_1 = [0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]\nexpected_result_1 = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nassert flatten_list(test_list_1) == expected_result_1\n\ntest_list_2 = [[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]\nexpected_result_2 = [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nassert flatten_list(test_list_2) == expected_result_2\n\ntest_list_3 = [[1,2,3], [4,5,6], [10,11,12], [7,8,9]]\nexpected_result_3 = [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nassert flatten_list(test_list_3) == expected_result_3\n\nprint(\"All tests passed!\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/229": [{"task_id": "Mbpp/229", "solution": "def re_arrange_array(arr, n):\n    neg_idx = 0\n    for i in range(n):\n        if arr[i] < 0:\n            arr[neg_idx], arr[i] = arr[i], arr[neg_idx]\n            neg_idx += 1\n    return arr", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[10, -5, -2, 7, 0, 0, 0, -10, -5], 9]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def decagonal_number(n):\n    return n * (9 * n - 7)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements(t):\n    count = 0\n    for item in t:\n        if isinstance(item, tuple):\n            return count\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    # Initialize the minimum value to the first element of the list\n    min_value = lst[0]\n\n    # Iterate through the elements of the list\n    for element in lst:\n        # Check if the element is smaller than the current minimum value\n        # and if it is not a string\n        if isinstance(element, int) and element < min_value:\n            min_value = element\n    \n    return min_value", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def values_string(string):\n    return string[::2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "Here is the function code without the test cases:\n\n```Python\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            j += 1\n            inv_count += (mid - i + 1)\n        k += 1\n    \n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    \n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n    \n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n    \n    return inv_count\n\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return _mergeSort(arr, temp_arr, 0, n - 1)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    \"\"\"\n    Function to find the highest power of 2 that is less than or equal to n.\n\n    Parameters:\n    n (int): The input number\n\n    Returns:\n    power (int): The highest power of 2\n\n    \"\"\"\n    power = 1\n    \n    while power <= n:\n        power *= 2\n        \n    return power // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(lst):\n    min_product = float('inf')\n    for tup in lst:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    left = 0\n    right = n - 1\n    \n    # Binary search to find the first occurrence of the element\n    while left <= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == element:\n            first_occurrence = mid\n            right = mid - 1\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # Binary search to find the last occurrence of the element\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == element:\n            last_occurrence = mid\n            left = mid + 1\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # Check if the element is the majority element\n    if (last_occurrence - first_occurrence + 1) > n // 2:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def k_type(tup):\n    dataType = type(tup[0])\n    for i in tup:\n        if type(i) != dataType:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/407": [{"task_id": "Mbpp/407", "solution": "def rearrange_bigger(num):\n    num_str = str(num)\n    n = len(num_str)\n\n    # Step 3: Finding the first digit 'i'\n    i = n - 1\n    while i > 0 and num_str[i] <= num_str[i-1]:\n        i -= 1\n    if i == 0:\n        return False\n\n    # Step 4: Finding the digit 'j'\n    j = i - 1\n\n    # Step 5: Finding the digit 'k'\n    k = n - 1\n    while num_str[k] <= num_str[j]:\n        k -= 1\n\n    # Step 6: Swapping positions of 'num_str[j]' and 'num_str[k]'\n    num_str = list(num_str)\n    num_str[j], num_str[k] = num_str[k], num_str[j]\n\n    # Step 7: Sorting the substring and concatenating the result\n    num_str = num_str[:i] + sorted(num_str[i:])\n    return int(\"\".join(num_str))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    sum_negative = 0\n    for num in numbers:\n        if num < 0:\n            sum_negative += num\n    return sum_negative", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] - list2[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "def next_Perfect_Square(n):\n    i = n + 1\n    while True:\n        if int(i ** 0.5) ** 2 == i:\n            return i\n        i += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] - tuple2[i])\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/164": [{"task_id": "Mbpp/164", "solution": "def sum_of_divisors(n):\n    divisor_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            if i != n // i:\n                divisor_sum += n // i\n    return divisor_sum\n\ndef are_equivalent(num1, num2):\n    return sum_of_divisors(num1) == sum_of_divisors(num2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(lst):\n    res = []\n    for tup in lst:\n        res.append(tup[-1])\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def val(lst):\n    maximum = None\n    for item in lst:\n        if isinstance(item, int) or isinstance(item, float):\n            if maximum is None or item > maximum:\n                maximum = item\n    return maximum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    position = 0\n    while n & (1 << position) != 0:\n        position += 1\n\n    # Check if all bits are already set\n    if position == len(bin(n)) - 2:  # Subtract 2 to exclude the '0b' prefix in the binary representation\n        return n\n\n    # Set the leftmost unset bit\n    return n | (1 << position)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurrence(s):\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == 'std':\n            count += 1\n            i += 3\n        else:\n            i += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tup, element):\n    return element in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(side1, side2):\n    # calculate the square of the two sides\n    side1_squared = side1 ** 2\n    side2_squared = side2 ** 2\n    \n    # calculate the sum of the squares\n    sum_of_squares = side1_squared + side2_squared\n    \n    # take the square root of the sum of squares to find the length of the hypotenuse\n    hypotenuse = math.sqrt(sum_of_squares)\n    \n    return hypotenuse", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    return tuple(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["hello   world"]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def _Power_Sum(n):\n    sum = 0\n    for i in range(1, (n*2)+1, 2):\n        sum += i**5\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/249": [{"task_id": "Mbpp/249", "solution": "def rsection_array(arr1, arr2):\n    return [x for x in arr1 if x in arr2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def range_list(lst, start, end):\n    return sum(lst[start:end+1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/400": [{"task_id": "Mbpp/400", "solution": "def act_freq(lst):\n    unique_tuples = set(lst)\n    return len(unique_tuples)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row\n    row_sum = sum(matrix[0])\n    \n    # Check if the sum of each row is equal to the first row sum\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n    \n    # Check if the sum of each column is equal to the first row sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != row_sum:\n            return False\n    \n    # Check if the sum of the main diagonal is equal to the first row sum\n    if sum(matrix[i][i] for i in range(n)) != row_sum:\n        return False\n    \n    # Check if the sum of the reverse diagonal is equal to the first row sum\n    if sum(matrix[i][n-i-1] for i in range(n)) != row_sum:\n        return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def divide(numerator, denominator):\n    return numerator // denominator", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    # Convert the number to binary\n    binary_num = bin(num)[2:]\n    \n    # Add leading zeros if necessary\n    binary_num = binary_num.zfill(len(binary_num) + len(binary_num) % 2)\n    \n    # Set all even bits to 1\n    even_bit_set = ''.join(['1' if i % 2 == 0 else binary_num[i] for i in range(len(binary_num))])\n    \n    # Convert the modified binary back to decimal\n    result = int(even_bit_set, 2)\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[20]], "plus_fail_tests": [[false]]}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re\n\ndef text_match_two_three(string):\n    # Using regex to match the pattern \"abbb\" or \"abbbb\"\n    pattern = r'ab{2,3}'\n    match = re.search(pattern, string)\n    \n    # If a match is found, return True. Otherwise, return False.\n    if match:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(test_cases):\n    total = 0\n    for num in test_cases.split('\\n'):\n        if isinstance(num, int):\n            num = abs(num) # Convert negative numbers to positive to compute sum of digits\n            while num > 0:\n                total += num % 10 # Add the last digit to the total\n                num = num // 10 # Remove the last digit\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    return a * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    max_len = 0\n    max_list = []\n\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n\n    return (max_len, max_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def e_product(list1, list2, n):\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    return products[:n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def i_value(char):\n    return ord(char)\n\n# Test cases\ntest_cases = ['A', 'R', 'S']\nfor test_case in test_cases:\n    assert i_value(test_case) == ord(test_case)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    current_sum = 0\n    odd_num = 1\n\n    for _ in range(n):\n        current_sum += odd_num\n        odd_num += 2\n\n    return current_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(num1, num2, num3):\n    numbers = [num1, num2, num3]\n    numbers.sort()  # Sort the numbers in ascending order\n    return numbers[1]  # Return the middle element", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    total_sum = 0\n    \n    for i in range(n+1):\n        if i % 2 == 0:\n            coefficient = math.comb(n, i)\n            total_sum += coefficient\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    count = 0\n    for i, char in enumerate(string):\n        if char.lower() == chr(ord('a') + i):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def re_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**2\n    return sum\n\n# Testing the function\nassert re_Sum(2) == 20\nassert re_Sum(3) == 56\nassert re_Sum(4) == 120\nprint(\"All test cases pass\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def sum_increasing_subseq(arr, n, i, k):\n    dp = [0] * n\n    dp[i] = arr[i]\n    for j in range(i+1, k+1):\n        dp[j] = arr[j]\n        for m in range(i, j):\n            if arr[j] > arr[m] and dp[j] < dp[m] + arr[j]:\n                dp[j] = dp[m] + arr[j]\n    return max(dp)\n\n# test cases\nassert sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\nassert sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\nassert sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 7", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/396": [{"task_id": "Mbpp/396", "solution": "def k_char(string):\n    if string[0] == string[-1]:\n        return \"Valid\"\n    else:\n        return \"Invalid\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def common_divisors_sum(a, b):\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n    return sum(common_divisors)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurrences(tuple_list):\n    occurrences = {}\n    for tup in tuple_list:\n        if tup in occurrences:\n            occurrences[tup] += 1\n        else:\n            occurrences[tup] = 1\n    return occurrences", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "I apologize for the confusion, but as an AI language model, I'm unable to directly view or access your code. However, if you provide me with more information about the issue you are facing or the specific function you want assistance with, I'll be happy to try to help you by providing guidance, explanations, or code snippets.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_sum(n):\n    sum_of_squares = 0\n    for i in range(1, 2*n, 2):\n        sum_of_squares += i*i\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(word_list):\n    words_with_p = []\n    for words in word_list:\n        words_with_p.extend(word for word in words.split() if word.startswith('P') or word.startswith('p'))\n        if len(words_with_p) >= 2:\n            break\n    return tuple(words_with_p[:2])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateral_surface_cube(side_length):\n    # Lateral surface area of a cube = 4 * (side_length)^2\n    return 4 * side_length ** 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        seq = [0] * (n + 1)\n        seq[1] = 1\n        seq[2] = 1\n\n        for i in range(3, n + 1):\n            seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\n        return seq[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    # Convert numbers to binary strings\n    binary_num1 = bin(num1)[2:]  # Remove '0b' prefix\n    binary_num2 = bin(num2)[2:]\n\n    # Ensure both binary strings have the same length by padding with zeros\n    max_length = max(len(binary_num1), len(binary_num2))\n    binary_num1 = binary_num1.zfill(max_length)\n    binary_num2 = binary_num2.zfill(max_length)\n\n    # Count the number of differing bits\n    diff_count = sum(bit1 != bit2 for bit1, bit2 in zip(binary_num1, binary_num2))\n\n    # Return True if only one bit differs, False otherwise\n    return diff_count == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, 10]]}], "Mbpp/83": [{"task_id": "Mbpp/83", "solution": "def get_Char(string):\n    total = sum(ord(char) for char in string) % 26\n    if total + ord('a') > 122:\n        return chr((total + ord('a')) % 26 + ord('a'))\n    else:\n        return chr(total + ord('a'))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0 or j == 0:\n                dp[i][j] = 0\n            elif j <= i - 1:\n                dp[i][j] = (i - j) * dp[i - 1][j] + (j + 1) * dp[i - 1][j - 1]\n\n    return dp[n][m]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    if n < 1:\n        return None\n    return n * (3 * n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def split(lst, n):\n    result = []\n    for i in range(n):\n        sublist = []\n        for j in range(i, len(lst), n):\n            sublist.append(lst[j])\n        result.append(sublist)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def max_num(nums):\n    nums.sort(reverse=True)\n    max_num = \"\"\n    for num in nums:\n        max_num += str(num)\n    return int(max_num)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    return 5 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n\n    total_count = 0\n    for i in range(1, m + 1):\n        total_count += get_total_number_of_sequences(i*2, n - 1)\n    return total_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(number):\n    if number <= 0:\n        return False\n    \n    n = 0\n    while True:\n        woodall = n * (2 ** n) - 1\n        if woodall == number:\n            return True\n        elif woodall > number:\n            return False\n        n += 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    if k <= 0 or k > len(arr):\n        return None\n    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef next_smallest_palindrome(num):\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime(num):\n    if num < 2:  \n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True  \n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n    return binary", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    unique_elements = set()\n    \n    for num in arr:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    \n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for d in (dict1, dict2, dict3):\n        for key, value in d.items():\n            if key in merged_dict:\n                pass\n            else:\n                merged_dict[key] = value\n    return merged_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "import math\n\ndef multiply_num(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    if len(word) % 2 == 0:\n        return False\n    else:\n        return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    # Base case\n    if len(arr) == 1:\n        return arr[0]\n    \n    # Calculate mid\n    mid = len(arr) // 2\n    \n    # Check if mid is even or odd\n    is_even = mid % 2 == 0\n    \n    # Check if mid is the unique element\n    if arr[mid] != arr[mid - 1] and arr[mid] != arr[mid + 1]:\n        return arr[mid]\n    \n    # Decide which half to continue\n    if is_even:\n        if arr[mid] == arr[mid + 1]:\n            return search(arr[:mid])  # Unique element is in the left half\n        else:\n            return search(arr[mid + 1:])  # Unique element is in the right half\n    else:\n        if arr[mid] == arr[mid - 1]:\n            return search(arr[:mid])  # Unique element is in the left half\n        else:\n            return search(arr[mid:])  # Unique element is in the right half", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    return string.split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        max_tuple = (max(tuple1[i]), max(tuple2[i]))\n        result.append(max_tuple)\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    if len(arr) < 2:\n        return None\n    \n    min_val = arr[0]\n    max_diff = abs(arr[1] - arr[0])\n    \n    for i in range(1, len(arr)):\n        if arr[i] - min_val > max_diff:\n            max_diff = arr[i] - min_val\n        if arr[i] < min_val:\n            min_val = arr[i]\n    \n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[9, 3, 2, 5, 1]]], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(string1, string2):\n    # Create a set of characters from string2 for faster lookup\n    char_set = set(string2)\n    # Filter out characters from string1 that are not in char_set\n    filtered_string = ''.join(char for char in string1 if char not in char_set)\n    return filtered_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(human_years):\n    if human_years <= 2:\n        dog_years = human_years * 10.5\n    else:\n        dog_years = 21 + (human_years - 2) * 4\n    \n    return dog_years", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def t_two_parts(lst, L):\n    if L >= len(lst):\n        return (lst, [])\n    else:\n        return (lst[:L], lst[L:])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    # Iterate through possible values of x\n    for x in range(n+1):\n        # Calculate the square of x\n        x_square = x * x\n        # Check if n - x^2 is a perfect square\n        if (n - x_square) >= 0 and ((n - x_square) ** 0.5).is_integer():\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_digit(number):\n    return number % 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    return 4 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(lst, sublist):\n    \"\"\"\n    Check if lst contains sublist.\n    \n    Args:\n        lst (list): The list to check.\n        sublist (list): The sublist to search for.\n        \n    Returns:\n        bool: True if sublist is found in lst, False otherwise.\n    \"\"\"\n    if not sublist:\n        return True  # An empty list is always a sublist\n    if len(sublist) > len(lst):\n        return False  # Sublist cannot be longer than lst\n    for i in range(len(lst) - len(sublist) + 1):\n        if lst[i:i+len(sublist)] == sublist:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] in vowels and s[right] in vowels:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        elif s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n    return ''.join(s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)\n\ndef test_code(test_cases):\n    for test_case in test_cases:\n        inputs, expected_output = test_case\n        \n        # Perform the test with inputs\n        actual_output = check_element(*inputs)\n        \n        # Compare the actual output with the expected output\n        if actual_output == expected_output:\n            print(\"Test Passed\")\n        else:\n            print(\"Test Failed\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    max_diff = 0\n    zeros_count = 0\n    ones_count = 0\n\n    for char in binary_string:\n        if char == '0':\n            zeros_count += 1\n        else:\n            ones_count += 1\n        diff = abs(zeros_count - ones_count)\n        max_diff = max(max_diff, diff)\n\n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["100000011100000000111111111000000011111101"]]}], "Mbpp/117": [{"task_id": "Mbpp/117", "solution": "def list_to_float(lst):\n    return [(float(x), float(y)) for x, y in lst]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    result = tuple(x / y for x, y in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_monotonic(arr):\n    increasing = True\n    decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n    \n    return increasing or decreasing", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def e_to_int(tup):\n    result = 0\n    for num in tup:\n        result = result * 10 + num\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(lst1, lst2):\n    return [x for x in lst1 if x not in lst2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    bell = [[0] * (n+1) for _ in range(n+1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        \n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def an_trapezium(a, b, c):\n    return (a + b + 2 * c) / 4", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def find_min_length(list_of_lists):\n    if not list_of_lists:\n        return 0  # Return 0 if the input list is empty\n    \n    min_length = len(list_of_lists[0])  # Initialize with length of first list\n    for sublist in list_of_lists:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n        base (float): Length of the base of the triangle.\n        height (float): Height of the triangle (perpendicular to the base).\n        length (float): Length of the prism (along the direction perpendicular to the base).\n\n    Returns:\n        float: Volume of the triangular prism.\n    \"\"\"\n    return 0.5 * base * height * length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    flattened_set = set()\n    for sublist in list_of_lists:\n        for num in sublist:\n            flattened_set.add(num)\n    return flattened_set", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "def zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n\n    if non_zero_count == 0:\n        return 0\n\n    ratio = zero_count / non_zero_count\n\n    return round(ratio, 6)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import cmath\n\ndef angle_complex(real, imag):\n    \"\"\"\n    Get the angle of a complex number given its real and imaginary parts.\n    \n    Args:\n    real (float): The real part of the complex number.\n    imag (float): The imaginary part of the complex number.\n    \n    Returns:\n    float: The angle (in radians) of the complex number.\n    \"\"\"\n    complex_num = complex(real, imag)\n    return cmath.phase(complex_num)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0", "1j"]]}], "Mbpp/115": [{"task_id": "Mbpp/115", "solution": "def empty_dit(lst):\n    if not isinstance(lst, list):\n        return False  # If input is not a list, return False\n\n    for item in lst:\n        if not isinstance(item, dict):\n            return False  # If any item is not a dictionary, return False\n        if item:  # If any dictionary is not empty, return False\n            return False\n    return True  # If all dictionaries are empty, return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2], [], []]]], "plus_fail_tests": [[[[], [], [], ["", "a", "ML", "not", "gA", "EnIODji", "e"], [], [], [], [], [], [], [], []]]]}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(nums):\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def longest_palindrome_subsequence(string):\n    n = len(string)\n    table = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        table[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if string[i] == string[j] and cl == 2:\n                table[i][j] = 2\n            elif string[i] == string[j]:\n                table[i][j] = table[i+1][j-1] + 2\n            else:\n                table[i][j] = max(table[i][j-1], table[i+1][j])\n    return table[0][n-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n    min_tuple = tuples_list[0]\n    for tup in tuples_list:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    # Define a custom sorting function based on the sum of each row\n    def row_sum(row):\n        return sum(row)\n\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=row_sum)\n\n    return sorted_matrix", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    # Base case: if n is 0, it cannot be represented as a sum of non-zero powers of 2\n    if n == 0:\n        return False\n    \n    # Continue dividing n by 2 until it becomes 1 or an odd number\n    while n > 1:\n        # If n is divisible by 2, continue dividing\n        if n % 2 == 0:\n            n //= 2\n        else:\n            # If n is not divisible by 2, it cannot be represented as a sum of non-zero powers of 2\n            return False\n    \n    # If n becomes 1, it can be represented as a sum of non-zero powers of 2\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-14]]}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    return (b, a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def ve_Occ(string, char):\n    first_index = string.find(char) # Find the first occurrence of the character\n    last_index = string.rfind(char) # Find the last occurrence of the character\n    \n    if first_index == -1 or last_index == -1: # If either of the occurrences doesn't exist\n        return string # Return the original string\n    \n    # Remove the first and last occurrence of the character using slicing\n    updated_string = string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n    \n    return updated_string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    total = 0\n    for element in lst:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(sublist)\n\n    return list(common_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(tup1, tup2):\n    result = tuple()\n    for i in range(len(tup1)):\n        result += (tup1[i] and tup2[i],)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[123, 456, 789, 10], [987, 654, 321, 10]]]}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def rotate_binary_string(binary_str, rotations):\n    count_odd = 0\n    for i in range(len(binary_str)):\n        if int(binary_str, 2) % 2 != 0:\n            count_odd += 1\n        binary_str = binary_str[-1] + binary_str[:-1]  # rotate the string\n    return count_odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(number):\n    # Convert the number to a string for easier manipulation\n    num_str = str(number)\n    \n    # Check if the length of the number is less than 3\n    if len(num_str) < 3:\n        return False\n    \n    # Iterate through the digits of the number\n    for i in range(2, len(num_str)):\n        # Check if the current digit is not equal to the previous digit and not equal to the digit two places before\n        if num_str[i] != num_str[i - 2] and num_str[i] != num_str[i - 1]:\n            return False\n    \n    # If the loop completes without returning False, the number is undulating\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2121212121212122]]}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateral_surface_cylinder(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Args:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    return 2 * math.pi * radius * height", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    count = 0\n    for item in lst:\n        if item == num:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(lst):\n    return sorted(lst, key=lambda x: x[1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(num1, num2, num3):\n    return min(num1, num2, num3)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(number):\n    # Convert the number to a string to iterate through its digits\n    num_str = str(number)\n    \n    # Initialize variables to store the sums of alternate digits\n    sum1 = 0\n    sum2 = 0\n    \n    # Iterate through the digits of the number\n    for i in range(len(num_str)):\n        # If the index is even, add the digit to sum1\n        if i % 2 == 0:\n            sum1 += int(num_str[i])\n        # If the index is odd, add the digit to sum2\n        else:\n            sum2 += int(num_str[i])\n    \n    # Calculate the absolute difference between the sums\n    difference = abs(sum1 - sum2)\n    \n    # Check if the difference is divisible by 11\n    if difference % 11 == 0:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    count = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num ** 2 for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return len(primes)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    max_diff = 0\n    for pair in tuple_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def ge_date_format(date):\n    year, month, day = date.split('-')\n    new_date = day + '-' + month + '-' + year\n    return new_date\n\n# Test the function\nprint(ge_date_format(\"2026-01-02\")) # Expected output: '02-01-2026'\nprint(ge_date_format(\"2020-11-13\")) # Expected output: '13-11-2020'\nprint(ge_date_format(\"2021-04-26\")) # Expected output: '26-04-2021'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    # Initialize a variable to store the length of the longest word\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the length of the current word is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def reverse_string(test_cases):\n    reverse_cases = []\n    for case in test_cases:\n        reverse_cases.append(case[::-1])\n    return reverse_cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None\n    \n    # Assume the first element is the smallest\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest element\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    # Split the string into words\n    words = string.split()\n    # Filter words with at least 4 characters\n    long_words = [word for word in words if len(word) >= 4]\n    return long_words", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(arr):\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for elem in lst:\n        if isinstance(elem, int):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def est_num(n):\n    return n - 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def sum_of_divisors(n):\n    total = 0\n    for i in range(1, n):\n        if n % i == 0:\n            total += i\n    return total\n\ndef amicable_numbers_sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        divisor_sum = sum_of_divisors(i)\n        if divisor_sum != i and sum_of_divisors(divisor_sum) == i:\n            total_sum += i + divisor_sum\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def er_oddnumbers(numbers):\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n    return odd_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(num):\n    count = 0\n    while num != 0:\n        count += num & 1\n        num = num >> 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(tuples_list):\n    max_product = float('-inf')  # Initialize maximum product to negative infinity\n\n    for pair in tuples_list:\n        product = abs(pair[0] * pair[1])  # Calculate the absolute product of the pair\n        \n        if product > max_product:  # Update max_product if a larger product is found\n            max_product = product\n\n    return max_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    volume = (4/3) * math.pi * radius**3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count_true(lst):\n    return sum(1 for item in lst if item is True)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    def is_valid_substring(sub):\n        return sum(map(int, sub)) == len(sub)\n\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if is_valid_substring(s[i:j]):\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return set1.intersection(set2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    # Get the length of the first tuple in the list\n    first_length = len(tuples_list[0])\n    \n    # Check if all tuples in the list have the same length as the first one\n    for tup in tuples_list:\n        if len(tup) != first_length:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(lst, substring):\n    results = []\n    for string in lst:\n        if substring in string:\n            results.append(True)\n        else:\n            results.append(False)\n    return results", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    sorted_lists = []\n    for sublist in list_of_lists:\n        sorted_sublist = sorted(sublist)\n        sorted_lists.append(sorted_sublist)\n    return sorted_lists", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(my_tuple):\n    result = []\n    for string in my_tuple:\n        result.append(string[-1])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(num):\n    digit_counts = {}\n    \n    # Count the frequency of each digit in the number\n    for digit in str(num):\n        digit_counts[digit] = digit_counts.get(digit, 0) + 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_counts.items():\n        if int(digit) < count:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\n\ndef convert(complex_nums):\n    polar = []\n    for complex_num in complex_nums:\n        polar.append(cmath.polar(complex_num))\n    return polar", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i*i*i\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    count = 0\n    for value in tup:\n        if value == element:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    return 3 * n ** 2 - 3 * n + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_case_string):\n    # Split the string by underscores\n    words = snake_case_string.split('_')\n    \n    # Capitalize the first letter of each word except the first one\n    camel_case_string = words[0] + ''.join(word.capitalize() for word in words[1:])\n    \n    return camel_case_string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    count = 0\n    for item1, item2, item3 in zip(list1, list2, list3):\n        if item1 == item2 == item3:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(t):\n    return '-'.join(str(i) for i in t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) // 6\n\ndef ahedral_number(n):\n    return (n * (n + 1) * (n + 2)) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def site_Signs(x, y):\n    return (x < 0 and y > 0) or (x > 0 and y < 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a*x + b*y == n:\n                return (x, y)\n    return None", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[499, 499, 4000]]}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(number):\n    # Convert the number to a string to reverse it easily\n    num_str = str(number)\n    \n    # Reverse the number and convert it back to an integer\n    reversed_num = int(num_str[::-1])\n    \n    # Check if the given number is one less than twice its reverse\n    if number == (2 * reversed_num - 1):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "```\ndef is_samepatterns(words, patterns):\n    if len(words) != len(patterns):\n        return False\n    \n    word_to_pattern = {}\n    pattern_to_word = {}\n\n    for word, pattern in zip(words, patterns):\n        if word in word_to_pattern:\n            if word_to_pattern[word] != pattern:\n                return False\n        else:\n            word_to_pattern[word] = pattern\n        \n        if pattern in pattern_to_word:\n            if pattern_to_word[pattern] != word:\n                return False\n        else:\n            pattern_to_word[pattern] = word\n    \n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    if isinstance(numbers, list):\n        return [num for num in numbers if num % 2 == 0]\n    else:\n        return [num for num in numbers.split(\"\\n\") if int(num) % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(nums):\n    negatives = []\n    for num in nums:\n        if num < 0:\n            negatives.append(num)\n    return negatives", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def act_nth_element(lst, n):\n    return [x[n] for x in lst]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    if a <= b:\n        return a\n    else:\n        return b\n\n# Testing the function\ntest_cases = [\n    (1, 2),   # Expected output: 1\n    (-5, -4), # Expected output: -5\n    (0, 0)    # Expected output: 0\n]\n\nfor test_case in test_cases:\n    a, b = test_case\n    result = minimum(a, b)\n    print(f\"Minimum of {a} and {b} is {result}\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    if num % 2 == 0:\n        return False\n    else:\n        return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list_tests():\n    test_cases = [\n        ([[1, 2], [3], [4, 5, 6]], 2, 3),\n        ([[1, 2, 2], [3], [4, 5, 6]], 2, 4),\n        ([[1, 2], [3], [4, 5, 6]], 7, 0),\n    ]\n    for lst, element, expected in test_cases:\n        result = count_element_in_list(lst, element)\n        if result != expected:\n            print(f\"Failed for lst={lst}, element={element}. Expected={expected}, got={result}\")\n        else:\n            print(f\"Passed for lst={lst}, element={element}.\")\n\ndef count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n\ncount_element_in_list_tests()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_sum(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        even_number = 2 * i\n        sum_of_cubes += even_number ** 3\n    return sum_of_cubes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def bola_directrix(a, h, k):\n    return -(4 * a * k - h ** 2) / (4 * a)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def iple_to_single(lst):\n    lst = [str(num) for num in lst]\n    res = int(\"\".join(lst))\n    return res", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/438": [{"task_id": "Mbpp/438", "solution": "def count_bidirectional(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][0] == lst[j][1] and lst[i][1] == lst[j][0]:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1]]]]}], "Mbpp/431": [{"task_id": "Mbpp/431", "solution": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        multiplied_tuple = tuple(tuple1[i][j] * tuple2[i][j] for j in range(len(tuple1[i])))\n        result.append(multiplied_tuple)\n    return tuple(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]]]}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    even_characters = \"\"\n    for i in range(len(string)):\n        if i % 2 == 1:\n            even_characters += string[i]\n    return even_characters", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    adverb = \"\"\n    position = 0\n    i = 0\n\n    while i < len(sentence):\n        if sentence[i].isalpha() or sentence[i] == \"'\":\n            break\n\n        i += 1\n\n    while i < len(sentence):\n        if sentence[i].isalpha() or sentence[i] == \"'\":\n            break\n\n        adverb += sentence[i]\n        position += 1\n        i += 1\n\n    return (0, position, adverb.strip('!'))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    # Calculate the surface area of the cube using the formula 6 * side_length^2\n    surface_area = 6 * side_length**2\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/442": [{"task_id": "Mbpp/442", "solution": "def positive_count(arr):\n    positive_nums = [num for num in arr if num > 0]\n    ratio = len(positive_nums) / len(arr)\n    return round(ratio, 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-2, 1, -6, -9, -11, -12, -14, -5, -17]]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    cubes = [num**3 for num in nums]\n    return cubes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return perrin(n-2) + perrin(n-3)\n\ndef cal_sum(n):\n    result = 0\n    for i in range(n+1):\n        result += perrin(i)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, size):\n    return [string for string in string_list if len(string) == size]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    area = length * width\n    return area\n\ndef angle_area(length, width):\n    area = length * width\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def _min(sublists):\n    min_length = float('inf')\n    min_sublist = []\n    for sublist in sublists:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_string = string[::-1]  # reversing the string\n        reversed_list.append(reversed_string)  # adding reversed string to the list\n    return reversed_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract(lst):\n    result = []\n    for sublst in lst:\n        result.append(sublst[0])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    result = ''\n    i = 0\n    while i < len(string):\n        if string[i].isupper():\n            j = i + 1\n            while j < len(string) and string[j].isupper():\n                j += 1\n            i = j\n        else:\n            result += string[i]\n            i += 1\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month_number):\n    thirty_one_days_months = [1, 3, 5, 7, 8, 10, 12]\n\n    if month_number in thirty_one_days_months:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "def match_wordz(word):\n    if 'z' in word:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def product(arr: List[int]) -> int:\n    n = len(arr)\n    max_product = 0\n    product = 1\n    for i in range(n):\n        if i + 1 < n and arr[i] < arr[i+1]:\n            product *= arr[i]\n        else:\n            product *= arr[i]\n            if product > max_product:\n                max_product = product\n            product = 1\n    return max_product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/461": [{"task_id": "Mbpp/461", "solution": "def upper_ctr(string):\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def subarray_product(arr):\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    result = [[]]  # start with an empty list as a combination\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            result.append(lst[i:j])  # add all possible sublists as combinations\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def pairwise(t):\n    result = []\n    for i in range(len(t)-1):\n        result.append(t[i] + t[i+1])\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def _empty(dic):\n    return {key: value for key, value in dic.items() if value is not None}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(nums, n):\n    product = 1\n    for num in nums:\n        product = (product * num) % n\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(lst, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (lst[i] ^ lst[j]) % 2 != 0:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(string):\n    pattern = r'\"(.*?)\"'\n    values = re.findall(pattern, string)\n    return values", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    sorted_dict = sorted(dictionary.items(), key=lambda kv: kv[1], reverse=True)\n    return sorted_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def n_elements(tuple1, tuple2):\n    # convert both tuples into sets to remove duplicates\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # find the union of the two sets\n    union_set = set1.union(set2)\n    \n    # convert the union set back into a tuple\n    sorted_tuple = tuple(sorted(union_set))\n    \n    return sorted_tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def t(lst):\n    return [num for num in lst if num % 2 != 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(lst1, lst2):\n    set1 = set(lst1)\n    set2 = set(lst2)\n    return set1.intersection(set2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit(num):\n    num_str = str(num)\n    return int(num_str[0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    # Converting numbers to string for easier manipulation of digits\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n\n    # Initializing the sum variable\n    sum_distance = 0\n\n    # Checking the length of the two numbers\n    max_length = max(len(str_num1), len(str_num2))\n\n    # Pad the shorter number with leading zeros if necessary\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n\n    # Calculating the per-digit difference and summing them up\n    for digit1, digit2 in zip(str_num1, str_num2):\n        sum_distance += abs(int(digit1) - int(digit2))\n\n    return sum_distance", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12345, 9]]}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(N):\n    return [{} for _ in range(N)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(lst):\n    # Create an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate through the list and add unique numbers to the set\n    for num in lst:\n        unique_numbers.add(num)\n    \n    # Initialize product variable with 1\n    product = 1\n    \n    # Iterate through the unique numbers and multiply them\n    for num in unique_numbers:\n        product *= num\n    \n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    sorted_list = sorted(lst)  # Sort the list in ascending order\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] != sorted_list[i-1] + 1:  # Check if the current number is not consecutive to the previous number\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        smallest = min(arr)\n        largest = max(arr)\n        return smallest + largest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    toggled_string = \"\"\n    \n    for char in string:\n        if char.islower():\n            toggled_string += char.upper()\n        else:\n            toggled_string += char.lower()\n    \n    return toggled_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def remove_duplicate_nums(*lists):\n    unique_nums = set()\n    for lst in lists:\n        unique_nums.update(lst)\n    return list(unique_nums)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_squared = sum(i ** 2 for i in range(1, n + 1))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_squared - sum_of_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10]]}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    new_string = \"\"\n    for char in string:\n        if char.isupper():\n            new_string += char\n    return new_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def t(string):\n    return list(string)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    # Initialize sum to 0\n    digit_sum = 0\n    \n    # Iterate through each digit in the number\n    while n > 0:\n        # Add the last digit to the sum\n        digit_sum += n % 10\n        # Remove the last digit from the number\n        n //= 10\n    \n    return digit_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(lst):\n    max_length = 0\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def rt_list(lst):\n    return lst == sorted(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def lower(string):\n    return string.lower()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(lst, length):\n    max_sum = lst[0]\n    current_sum = lst[0]\n    \n    for i in range(1, length):\n        current_sum = max(lst[i], current_sum + lst[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] != lst[j]:\n                count += 1\n    return count\n\ndef test_code():\n    test_cases = [\"1 2 3 4 5\", \"10 20 30 40 50\"]\n    for test_case in test_cases:\n        lst = test_case.split(\" \")\n        result = count_Pairs(lst)\n        print(f\"Input: {test_case}\\nOutput: {result}\")\n\ntest_code()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/574": [{"task_id": "Mbpp/574", "solution": "def acearea_cylinder(radius, height):\n    # Calculate the area of the circular top and bottom\n    area_top_bottom = 2 * 3.14159 * (radius**2)\n\n    # Calculate the area of the curved side\n    area_side = 2 * 3.14159 * radius * height\n\n    # Calculate the total surface area\n    surface_area = area_top_bottom + area_side\n\n    return round(surface_area, 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    for sublst in lst:\n        sublst.sort()\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    def _Digit_Factorial(n):\n        factorial = 1\n        if n == 0 or n == 1:\n            return 1\n        else:\n            for i in range(2, n + 1):\n                factorial *= i\n            return factorial % 10\n    \n    return _Digit_Factorial(n)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(lst, sub_lst):\n    # Check if sub_lst is empty\n    if len(sub_lst) == 0:\n        return True\n\n    # Check if lst is empty or sub_lst is larger than lst\n    if len(lst) == 0 or len(lst) < len(sub_lst):\n        return False\n\n    # Iterate through lst\n    for i in range(len(lst)):\n        # Check if sub_lst can fit starting from index i in lst\n        if lst[i:i+len(sub_lst)] == sub_lst:\n            return True\n\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def _tuple(lst):\n    return tuple(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    # split the list at the nth element\n    part1 = arr[:n]\n    part2 = arr[n:]\n    \n    # add the first part to the end\n    new_arr = part2 + part1\n    \n    return new_arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def _dissimilar(tuple1, tuple2):\n    return tuple(sorted(set(tuple1) ^ set(tuple2)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def is_even(n):\n    return n % 2 == 0\n\ndef extract_even(t):\n    if isinstance(t, tuple):\n        return tuple(extract_even(e) for e in t if is_even(e))\n    else:\n        return t if is_even(t) else None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "import math\n\ndef binomial_coefficient(n, r):\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\n\ndef sum_Of_product(n):\n    total = 0\n    \n    for r in range(1, n):\n        total += binomial_coefficient(n, r) * binomial_coefficient(n, r-1)\n        \n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/582": [{"task_id": "Mbpp/582", "solution": "def check_empty_dict(my_dict):\n    if not my_dict:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    # Check if n is 0 or 1\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize the numerator and denominator\n    numerator = 1\n    denominator = 1\n    \n    # Calculate the factorial of 2n\n    for i in range(2, 2*n + 1):\n        numerator *= i\n    \n    # Calculate the factorial of n+1\n    for i in range(2, n + 2):\n        denominator *= i\n    \n    # Calculate the factorial of n\n    for i in range(2, n + 1):\n        denominator *= i\n    \n    # Calculate and return the nth Catalan number\n    return numerator // (denominator * denominator)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_Area(base_edge, height):\n    side_area = base_edge**2\n    perimeter = 4 * base_edge\n    base_area = base_edge**2\n    lateral_area = (perimeter * height) / 2\n    surface_area = base_area + lateral_area\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(lst):\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    result = []\n    for i in range(start, end+1):\n        if int(i**0.5)**2 == i:\n            result.append(i)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items(dataset, n):\n    sorted_dataset = sorted(dataset, key=lambda item: item['price'], reverse=True)\n    return sorted_dataset[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def kth_smallest(arr1, arr2, k):\n    merged = merge_arrays(arr1, arr2)\n    return merged[k-1]\n\ndef merge_arrays(arr1, arr2):\n    merged = []\n    i = 0\n    j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(lst):\n    if not lst:\n        return None\n    else:\n        return max(lst) - min(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\r\n    # Convert the number to string and find the length\r\n    num_str = str(num)\r\n    num_len = len(num_str)\r\n\r\n    # Calculate the sum of the digits raised to the power of number length\r\n    sum = 0\r\n    for digit in num_str:\r\n        sum += int(digit) ** num_len\r\n\r\n    # Check if the sum is equal to the original number\r\n    return sum == num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(tup):\n    return sys.getsizeof(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath\n\ndef polar_rect(r, theta):\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    return (abs(x), abs(y))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    even_number = None\n    odd_number = None\n  \n    for num in lst:\n        if num % 2 == 0 and even_number is None:\n            even_number = num\n        elif num % 2 == 1 and odd_number is None:\n            odd_number = num\n        \n        if even_number is not None and odd_number is not None:\n            return even_number - odd_number\n    \n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "import inspect\n\ndef get_function_code(func):\n    \"\"\"Returns the code of a given function.\"\"\"\n    return inspect.getsource(func)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    # Create a dictionary to keep track of character counts\n    char_counts = {}\n\n    # Loop through each character in the string\n    for char in s:\n        # If the character is already in the dictionary, it is repeated\n        if char in char_counts:\n            return char\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_counts[char] = 1\n\n    # If no repeated character is found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    components = ip_address.split('.')\n    for i in range(len(components)):\n        components[i] = str(int(components[i]))\n    updated_ip_address = '.'.join(components)\n    return updated_ip_address\n\n# Testing the function with the given test cases\ntest_cases = '''216.08.094.196\n12.01.024\n216.08.094.0196'''\n\nfor test_case in test_cases.split('\\n'):\n    if test_case == '':\n        continue\n    ip = removezero_ip(test_case)\n    print(f\"removezero_ip({test_case}) = {ip}\")", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_number(n):\n    bell = [[0 for j in range(n+1)] for i in range(n+1)]\n    bell[0][0] = 1\n\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n\n    return bell[n][0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    words = string.split()  # Split the string into a list of words\n    words.reverse()  # Reverse the order of words in the list\n    return ' '.join(words)  # Join the words with spaces and return the reversed string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    results = []\n    \n    for num in n:\n        # Calculate the sum of first 'num' natural numbers\n        sum_of_numbers = (num * (num + 1)) // 2\n        \n        # Calculate the average of first 'num' natural numbers\n        average_of_numbers = sum_of_numbers / num\n        \n        results.append((sum_of_numbers, average_of_numbers))\n    \n    return results", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/595": [{"task_id": "Mbpp/595", "solution": "def min_Swaps(num1, num2):\n    count1 = num1.count('1')\n    count2 = num2.count('1')\n\n    # Check if the two binary numbers have same number of 1s\n    if count1 != count2:\n        return \"Not Possible\"\n\n    # Initialize the swap count\n    swaps = 0\n\n    # Iterate through each index of the binary numbers\n    for i in range(len(num1)):\n        if num1[i] == '1' and num2[i] == '0':\n            swaps += 1\n\n    return swaps", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["111", "000"]], "plus_fail_tests": [["1111111111111111111111111111111111111111111111111111111111111111", "0000000000000000000000000000000000000000000000000000000000000000"]]}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        start_index = match.start()\n        end_index = match.end()\n        return text[start_index:end_index], start_index, end_index\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def e(lst):\n    first_list = []\n    second_list = []\n    \n    for sublist in lst:\n        first_list.append(sublist[0])\n        second_list.append(sublist[1])\n    \n    return [first_list, second_list]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nums(numbers, n):\n    return [num ** n for num in numbers]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def list_function(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        try:\n            result.append(float(list1[i])/float(list2[i]))\n        except ZeroDivisionError:\n            result.append(0.0)  # handle division by zero\n        except ValueError:\n            result.append(0.0)  # handle invalid values\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "def degree_radian(degree):\n    radian = degree * (math.pi/180)\n    return radian", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    max_val = float('-inf')\n    for row in matrix:\n        if row[n] > max_val:\n            max_val = row[n]\n    return max_val", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def median(list1, list2, size):\n    merged_list = list1 + list2\n    merged_list.sort()\n    median_index = (size * 2) // 2\n    if size % 2 == 0:\n        median = (merged_list[median_index - 1] + merged_list[median_index]) / 2\n    else:\n        median = merged_list[median_index]\n    return median", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] % tuple2[i])\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cumulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        for val in tup:\n            total_sum += val\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(num):\n    if num % 2 == 0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    nums = []\n    non_nums = []\n\n    if isinstance(string, str):\n        for char in string:\n            if char.isdigit():\n                nums.append(char)\n            else:\n                non_nums.append(char)\n\n        return ''.join(non_nums + nums)\n    else:\n        return \"Error: Input should be a string\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    count = {}\n    for num in numbers:\n        if num % 2 == 0:\n            count[num] = count.get(num, 0) + 1\n    max_count = max(count.values()) if count else 0\n    return max_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(string):\n    return string.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "import math\n\ndef triangle_area(radius):\n    if radius <= 0:\n        return None\n    else:\n        return (radius**2) * math.sqrt(3) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0]], "plus_fail_tests": [[0.5]]}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple(t):\n  result = []\n  for tpl in t:\n    avg = sum(tpl) / len(tpl)\n    result.append(avg)\n  return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def ace_spaces(string):\n    return string.replace(\" \", \"%20\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def split(nums):\n    even_nums = []\n    odd_nums = []\n    for num in nums:\n        if num % 2 == 0:\n            even_nums.append(num)\n        else:\n            odd_nums.append(num)\n    return even_nums, odd_nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/295": [{"task_id": "Mbpp/295", "solution": "def sum_div(num):\n    divisors = []\n    for i in range(1, num+1):\n        if num % i == 0:\n            divisors.append(i)\n    return sum(divisors)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    # Create a max heap\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from the heap one by one\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Swap root (max element) with last element\n        heapify(arr, i, 0)  # Heapify the reduced heap\n    \n    return arr\n\ndef heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # Check if left child of root exists and is greater than the root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # Check if right child of root exists and is greater than the root\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, n, largest)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def match_wordz_middle(word):\n    if len(word) < 3:\n        return False\n    else:\n        for i in range(1, len(word)-1):\n            if word[i] == 'z':\n                return True\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def _chill(velocity, temperature):\n    wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * velocity ** 0.16 + 0.3965 * temperature * velocity ** 0.16\n    return int(wind_chill_index + 0.5)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def my_function():\n    # Your code here\n    pass", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    result = ()\n    for i in range(len(t)-1):\n        result += (t[i] * t[i+1],)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def nonagonal(n):\n    return n * (7 * n - 5) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def ace_specialchar(string):\n    string = string.replace(\" \", \":\")\n    string = string.replace(\",\", \":\")\n    string = string.replace(\".\", \":\")\n    \n    return string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def k_none(tup):\n    for item in tup:\n        if item is None:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re\n\ndef extract_quotation(string):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    new_string = \"\"\n    for char in string:\n        if char == \" \":\n            new_string += \"_\"\n        elif char == \"_\":\n            new_string += \" \"\n        else:\n            new_string += char\n    return new_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def _insertion(arr, target):\n    left = 0\n    right = len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        elif arr[mid] >= target:\n            right = mid\n    return left", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def le_middle_bits(num):\n    if num == 0:\n        return 1\n    count = 0\n    temp = num\n    while temp:\n        count += 1\n        temp >>= 1\n    mask = (1 << (count - 1)) - 1\n    return num ^ mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    zeros = lst.count(0)  # count the number of zeros in the list\n    return [elem for elem in lst if elem != 0] + [0] * zeros", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "def lateralsurface_cone(r, h):\n    slant_height = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * slant_height\n    return lateral_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/640": [{"task_id": "Mbpp/640", "solution": "def ve_parenthesis(strings):\n    result = []\n    for string in strings:\n        new_string = ''\n        inside_parenthesis = False\n        for char in string:\n            if char == '(':\n                inside_parenthesis = True\n            elif char == ')':\n                inside_parenthesis = False\n            else:\n                if not inside_parenthesis:\n                    new_string += char\n        result.append(new_string)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n\n    for i in range(0, n):\n        for j in range(i+1, n):\n            sum += arr[i] ^ arr[j]\n    \n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(side_length):\n    return math.sqrt(3) * (side_length ** 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def dict_to_tuple(tup, dict):\n    new_tuple = tup + (dict,)\n    return new_tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    if cost_price == selling_price:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def list_sum(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_of_subarray_prod(arr):\n    n = len(arr)\n    result = 0\n\n    # Loop through all elements in the array\n    for i in range(n):\n        # Calculate the contribution of arr[i] to the sum\n        # This includes all subarrays ending at arr[i]\n        left_prod = 1\n        for j in range(i, -1, -1):\n            left_prod *= arr[j]\n            # Add the contribution to the result\n            result += left_prod\n        \n        # Reset the product for the next iteration\n        right_prod = 1\n\n        # Calculate the contribution of arr[i] to the sum\n        # This includes all subarrays starting at arr[i]\n        for j in range(i + 1, n):\n            right_prod *= arr[j]\n            # Add the contribution to the result\n            result += right_prod\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(lst):\n    result = [int(x) for x in lst] \n    result.sort()\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s):\n    return all(char == s[0] for char in s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    result = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            result.append(lst[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    result = base ** power\n    return sum(int(digit) for digit in str(result))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def _first_occurrence(arr, num):\n    start = 0\n    end = len(arr) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n\n        if arr[mid] == num:\n            if mid == 0 or arr[mid - 1] != num:\n                return mid\n            else:\n                end = mid - 1\n        elif arr[mid] < num:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def le_nam(names):\n    total_length = 0\n    for name in names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def er_data(student_dict, min_height, min_weight):\n    filtered_students = {}\n    \n    for name, (height, weight) in student_dict.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    result = \"\"\n    for i in range(len(s)):\n        if s[i].isupper() and i > 0:\n            result += \" \"\n        result += s[i]\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/746": [{"task_id": "Mbpp/746", "solution": "def sector_area(radius, angle):\n    if angle > 360:\n        return None\n    else:\n        return (0.5 * radius**2 * angle * 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148) / 180", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    n = len(tup)\n    if n % 2 != 0:\n        raise ValueError(\"Input tuple length must be even\")\n\n    result = {}\n    for i in range(0, n, 2):\n        result[tup[i]] = tup[i+1]\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_str(string):\n    return re.match(r'^[aeiouAEIOU]', string) is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        if all(num % int(digit) == 0 for digit in str(num) if int(digit) != 0):\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(arr, k):\n    # Return if k is 0 or the array is empty\n    if k == 0 or len(arr) == 0:\n        return arr\n\n    # Calculate the effective rotation length\n    k = k % len(arr)\n\n    # Reverse the entire array\n    reverse(arr, 0, len(arr) - 1)\n\n    # Reverse first k elements\n    reverse(arr, 0, k - 1)\n\n    # Reverse remaining elements\n    reverse(arr, k, len(arr) - 1)\n\n    return arr\n\n# Helper function to reverse a sublist within the array\ndef reverse(arr, start, end):\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    n = len(arr)\n    # Iterate through all internal nodes\n    for i in range(n // 2 - 1, -1, -1):\n        # Check if the current node is greater than any of its children\n        if arr[i] > arr[2 * i + 1] or (2 * i + 2 < n and arr[i] > arr[2 * i + 2]):\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    factors = []\n    for i in range(1, n+1):\n        if n % i == 0 and i % 2 == 0:\n            factors.append(i)\n    return sum(factors)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    records.sort(key=lambda x: x[1])\n    return records[:k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    # Create an empty dictionary to store the counts of reverse pairs\n    reverse_pairs = {}\n    \n    # Iterate through each string in the list\n    for string in string_list:\n        # Sort the characters of the string to create a key for the dictionary\n        sorted_string = ''.join(sorted(string))\n        \n        # Check if the sorted string exists in the dictionary\n        if sorted_string in reverse_pairs:\n            # Increment the count if the sorted string exists\n            reverse_pairs[sorted_string] += 1\n        else:\n            # Otherwise, add the sorted string to the dictionary with a count of 1\n            reverse_pairs[sorted_string] = 1\n    \n    # Initialize a variable to store the count of reverse pairs\n    count = 0\n    \n    # Iterate through the values in the dictionary\n    for value in reverse_pairs.values():\n        # If a string occurs more than once, it forms pairs with its reverse\n        # Increment the count by the combination of pairs\n        count += (value * (value - 1)) // 2\n    \n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["abc", "cba", "def", "fed", "hij", "jih", "klm", "mlk", "def"]]]}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(nums):\n    if len(set(nums)) < 2:  # If there are fewer than 2 unique numbers\n        return None\n    \n    unique_nums = sorted(set(nums))\n    return unique_nums[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        sublist_count[sublist_tuple] = sublist_count.get(sublist_tuple, 0) + 1\n    return sublist_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def _min_diff(arr, n):\n    # Sort the array\n    arr.sort()\n    \n    # Initialize minimum difference\n    diff = float('inf')\n    \n    # Find the minimum difference by comparing adjacent elements\n    for i in range(n-1):\n        if arr[i+1] - arr[i] < diff:\n            diff = arr[i+1] - arr[i]\n    \n    return diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    for char in expression:\n        if char in [\"(\", \"{\", \"[\"]:\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            current_char = stack.pop()\n            if current_char == \"(\":\n                if char != \")\":\n                    return False\n            if current_char == \"{\":\n                if char != \"}\":\n                    return False\n            if current_char == \"[\":\n                if char != \"]\":\n                    return False\n    if stack:\n        return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    if month in [4, 6, 9, 11]:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "import re\n\ndef is_decimal(s):\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["123"]]}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def num_sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i - 1) ** 4\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "def _combinations(lst):\n    import itertools\n    combinations = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            sum_tuple = tuple(map(sum, itertools.zip_longest(lst[i], lst[j], fillvalue=0)))\n            combinations.append(sum_tuple)\n    return combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    sum = 0\n    for num in lst:\n        if lst.count(num) == 1:\n            sum += num\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_string):\n    tuple_string = tuple_string.replace(\"(\", \"\").replace(\")\", \"\")\n    tuple_list = tuple_string.split(\", \")\n    integer_tuple = tuple(map(int, tuple_list))\n    return integer_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def ve_length(string, k):\n    words = string.split()\n    new_words = []\n    for word in words:\n        if len(word) != k:\n            new_words.append(word)\n    new_string = ' '.join(new_words)\n    return new_string", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested(tup):\n    return tuple(item for item in tup if not isinstance(item, tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def even_odd(lst):\n    even_product = 1\n    odd_product = 1\n    for num in lst:\n        if num % 2 == 0:  # check if number is even\n            even_product *= num\n        else:\n            odd_product *= num\n    return even_product * odd_product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(arr, target):\n    count = 0\n    freq = {}\n\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for num in arr:\n        required_num = target - num\n\n        if required_num in freq:\n            count += freq[required_num]\n\n            if required_num == num:\n                count -= 1\n\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 8]]}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(nums):\n    n = len(nums)\n    total_sum = 0\n    for i in range(n):\n        occur = (i + 1) * (n - i)\n        if occur % 2 != 0:\n            total_sum += nums[i] * occur\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    count = 0\n    if a == b == c:\n        count = 3\n    elif a == b or a == c or b == c:\n        count = 2\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the number at even index is odd\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "def occurrence_substring(string, substring):\n    if substring not in string:\n        return None\n    \n    start = string.find(substring)\n    end = start + len(substring)\n    \n    return (substring, start, end)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    packed_lst = []\n    i = 0\n    while i < len(lst):\n        sublist = [lst[i]]\n        while i+1 < len(lst) and lst[i+1] == lst[i]:\n            sublist.append(lst[i+1])\n            i += 1\n        packed_lst.append(sublist)\n        i += 1\n    return packed_lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    diff = []\n    for element in list1:\n        if element not in list2:\n            diff.append(element)\n    for element in list2:\n        if element not in list1 and element not in diff:\n            diff.append(element)\n    return diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [2, 4, 6, 8, 10]]]}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    count = 0\n    for item in lists:\n        if isinstance(item, list):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re\n\ndef text_match_three(text):\n    pattern = 'ab{3}'\n    return re.search(pattern, text) is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\n\ndef text_starta_endb(text):\n    pattern = re.compile(r'^a.*b$')\n    return bool(pattern.match(text))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    return (n << d | n >> (32 - d)) & 0xFFFFFFFF", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, target):\n    \"\"\"\n    Function to locate the right insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list.\n    target (int): The value to be inserted.\n\n    Returns:\n    int: The index where the target value should be inserted in order to maintain the sorted order.\n    \"\"\"\n\n    # Edge case: if the target is greater than the last element of the array\n    if target > arr[-1]:\n        return len(arr)\n\n    # Binary search to find the right insertion point\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    return sum(dictionary.values())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    left = 0\n    right = len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    return sum(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple(list_val, str_val):\n    return tuple(list_val + [str_val])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/783": [{"task_id": "Mbpp/783", "solution": "import colorsys\n\ndef rgb_to_hsv(red, green, blue):\n    # Convert RGB to normalized values between 0 and 1\n    red = red / 255.0\n    green = green / 255.0\n    blue = blue / 255.0\n    \n    # Convert normalized RGB to HSV\n    hsv = colorsys.rgb_to_hsv(red, green, blue)\n    \n    # Convert HSV values to degrees and percentages\n    hue = round(hsv[0] * 360, 2)\n    saturation = round(hsv[1] * 100, 2)\n    value = round(hsv[2] * 100, 2)\n    \n    return (hue, saturation, value)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0, 215, 0]], "plus_fail_tests": [[0, 0, 1]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0  # Initialize the maximum run length\n    current_run = 0  # Initialize the current run length\n\n    for char in s:\n        if char.isupper():  # Check if the character is uppercase\n            current_run += 1  # Increment the current run length\n            max_run = max(max_run, current_run)  # Update the maximum run if needed\n        else:\n            current_run = 0  # Reset the current run length if the character is not uppercase\n\n    return max_run", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(list_of_lists):\n    max_sum = float('-inf')\n    max_sum_list = None\n    \n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n    \n    return max_sum_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "```cpp\nbool is_perfect_square(int num) {\n    for (int i = 1; i * i <= num; i++) {\n        if (num % i == 0 && num / i == i) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    return k in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None\n\ndef t_odd(numbers):\n    # Placeholder function, incomplete implementation\n    pass\n\n# Test cases\nassert first_odd([2, 4, 6, 8, 9]) == 9\nassert first_odd([1, 2, 3, 4, 5]) == 1\nassert first_odd([2, 4, 6, 8, 10]) == None  # Expected value missing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    sum = 0\n    for i in range(l, r+1):\n        if i % 2 != 0:  # checking if number is odd\n            sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    return all(i > j for i, j in zip(tuple1, tuple2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    x, y = coord\n    coordinates = []\n\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            coordinates.append([i, j])\n\n    return coordinates", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num/2)+1):\n        if num % i == 0:\n            return False\n    return True\n\ndef e_num(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num/2)+1):\n        if num % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[999999999989]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    primes = []\n    num = 0\n    while len(primes) < n:\n        if is_prime(num) and is_prime(2*num + 1):\n            primes.append(num)\n        num += 2\n    return primes[n - 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2*jacobsthal_num(n-2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    i = 1\n    while True:\n        num = (i * (i + 1)) // 2\n        if len(str(num)) == n:\n            return i\n        i += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    count = 0\n    num = 1\n    \n    while count < n:\n        num += 1\n        divisors = 0\n        \n        for i in range(1, num+1):\n            if num % i == 0:\n                divisors += 1\n        \n        if divisors % 2 == 0:\n            count += 1\n            \n    return num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0\n\ndef solve(test_cases):\n    results = []\n    for n in test_cases:\n        results.append(count_divisors(n))\n    return results", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "import itertools\n\ndef combinations_colors(lst, n):\n    combinations = sorted(list(itertools.combinations(lst, n)))\n    return combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}]}}